<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Tjeu Groothuijsen" />

<meta name="date" content="2025-10-17" />

<title>DataprepFinal</title>

<script src="site_libs/header-attrs-2.29/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-6.5.2/css/all.min.css" rel="stylesheet" />
<link href="site_libs/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>


<link rel="stylesheet" href="tweaks.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    My journal
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="lab1.html">Example</a>
    </li>
    <li>
      <a href="week1hw.html">Research questions</a>
    </li>
    <li>
      <a href="week2class.html">Introduction</a>
    </li>
    <li>
      <a href="week3scrape.html">First data</a>
    </li>
    <li>
      <a href="week4network.html">Network: first attempt</a>
    </li>
    <li>
      <a href="week6function.html">The 'fun' in function</a>
    </li>
    <li>
      <a href="week7gof.html">Goodness that Fit!</a>
    </li>
  </ul>
</li>
<li>
  <a href="FinalDataPrep.html">Data preparation</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Final assignment
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="finalIntro.html">Introduction</a>
    </li>
    <li>
      <a href="finalTheory.html">Theory</a>
    </li>
    <li>
      <a href="finalMethods.html">Methods</a>
    </li>
    <li>
      <a href="finalAnalyses.html">Analyses</a>
    </li>
    <li>
      <a href="finalConclusion.html">Conclusion</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/GroothuijsenTjeu/GroothuijsenTlabjournal">
    <span class="fab fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">DataprepFinal</h1>
<h4 class="author">Tjeu Groothuijsen</h4>
<h4 class="date">2025-10-17</h4>

</div>


<hr />
<p>This page documents the preparation of the data for use in the final
assignment. Everything is placed in order of when I did it, mostly as a
reference for myself. All of this stuff is more neatly integrated in the
final assignment pages.</p>
<p>The following steps are taken to make the data suitable for assessing
whether clustering in the collaboration network of sociologists in the
Netherlands occurs due to preferential attachment to colleagues who
attended the same graduate school. For now, I am only distinguishing ICS
instead of including all graduate schools. This is because the ICS data
is easily obtained and includes a large proportion of sociologists. If
the proportion of sociologists affiliated with ICS turns out to be too
low, more data will be sought.</p>
<p>Plan: 1. Loading neccesary packages and functions 2. Webscrape data
about graduates and affiliates from the ICS website, make these into a
list of names 3. Load ‘scholars’ data containing the sociologists and
collaborations, remove polisci and irrelevant variables 4. Match list of
ICS affiliates to scholars data using names 5. Make merged dataset
suitable for analysis with RSiena 6. Analyse descriptive statistics</p>
<pre class="r"><code>#Loading in the necessary packages and defining functions
#Empties your environment, remove hash only if you are sure everything important is saved!
#rm(list = ls())

#Defining custom functions

#Jochems functions
#fpackage.check: Check if packages are installed (and install if not) in R
fpackage.check &lt;- function(packages) {
    lapply(packages, FUN = function(x) {
        if (!require(x, character.only = TRUE)) {
            install.packages(x, dependencies = TRUE)
            library(x, character.only = TRUE)
        }
    })
}

#fsave: Save to processed data in repository
fsave &lt;- function(x, file = NULL, location = &quot;./data/processed/&quot;) {
    ifelse(!dir.exists(&quot;data&quot;), dir.create(&quot;data&quot;), FALSE)
    ifelse(!dir.exists(&quot;data/processed&quot;), dir.create(&quot;data/processed&quot;), FALSE)
    if (is.null(file))
        file = deparse(substitute(x))
    datename &lt;- substr(gsub(&quot;[:-]&quot;, &quot;&quot;, Sys.time()), 1, 8)
    totalname &lt;- paste(location, datename, file, &quot;.rda&quot;, sep = &quot;&quot;)
    save(x, file = totalname)  #need to fix if file is reloaded as input name, not as x. 
}

#fload: To load the files back after an fsave
fload &lt;- function(filename) {
    load(filename)
    get(ls()[ls() != &quot;filename&quot;])
}

#fshowdf: To print objects (tibbles / data.frame) nicely on screen in .rmd
fshowdf &lt;- function(x, ...) {
    knitr::kable(x, digits = 2, &quot;html&quot;, ...) %&gt;%
        kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;)) %&gt;%
        kableExtra::scroll_box(width = &quot;100%&quot;, height = &quot;300px&quot;)
}

#Network data helper function
fcolnet = function(data = scholars, university = c(&quot;RU&quot;, &#39;UU&#39;), discipline = &quot;Sociologie&quot;, waves = list(c(2015,
    2018), c(2019, 2023), c(2024, 2025)), type = c(&quot;first&quot;)) {

    university = paste0(&#39;(&#39;, paste0(university, collapse=&#39;|&#39; ), &#39;)&#39;)
    discipline = paste0(&#39;(&#39;, paste0(discipline, collapse=&#39;|&#39; ), &#39;)&#39;)

    # step 1
    demographics = data$demographics
    sample = which(
        (str_detect(demographics$universiteit.22, university)
            | str_detect(demographics$universiteit.24, university)
            | str_detect(demographics$universiteit.25, university)
        ) &amp; (
            str_detect(demographics$discipline.22, discipline)
            | str_detect(demographics$discipline.24, discipline)
            | str_detect(demographics$discipline.25, discipline)
        ) |&gt; replace_na(FALSE))

    demographics_soc = demographics[sample, ] |&gt; drop_na(id)

    # step 2
    ids = demographics_soc$id |&gt; unique()

    scholars_sel = list() 
    for (id_ in ids){
        scholars_sel[[id_]] = bind_rows(scholars$works) |&gt;
            filter(author_id == id_)
    }
    scholars_sel = bind_rows(scholars$works) 
    

    nwaves = length(waves)
    nets = array(0, dim = c(nwaves, length(ids), length(ids)), dimnames = list(wave = 1:nwaves, ids,
        ids))
    dimnames(nets)

    # step 3
    df_works = tibble(
            works_id = scholars_sel$id, 
            works_author = scholars_sel$authorships, 
            works_year = scholars_sel$publication_year
        )

    df_works = df_works[!duplicated(df_works), ]

    # step 4
    if (type == &quot;first&quot;) {
        for (j in 1:length(waves)) {
            df_works_w = df_works[df_works$works_year &gt;= waves[[j]][1] &amp; df_works$works_year &lt;= waves[[j]][2],
                ]
            for (i in 1:nrow(df_works_w)) {
                ego = df_works_w$works_author[i][[1]]$id[1]
                alters = df_works_w$works_author[i][[1]]$id[-1]
                if (sum(ids %in% ego) &gt; 0 &amp; sum(ids %in% alters) &gt; 0) {
                  nets[j, which(ids %in% ego), which(ids %in% alters)] = 1
                }
            }
        }
    }

    if (type == &quot;last&quot;) {
        for (j in 1:length(waves)) {
            df_works_w = df_works[df_works$works_year &gt;= waves[[j]][1] &amp; df_works$works_year &lt;= waves[[j]][2],
                ]
            for (i in 1:nrow(df_works_w)) {
                ego = rev(df_works_w$works_author[i][[1]]$id[1])
                alters = rev(df_works_w$works_author[i][[1]]$id[-1])
                if (sum(ids %in% ego) &gt; 0 &amp; sum(ids %in% alters) &gt; 0) {
                  nets[j, which(ids %in% ego), which(ids %in% alters)] = 1
                }
            }
        }
    }
    if (type == &quot;all&quot;) {
        for (j in 1:length(waves)) {
            df_works_w = df_works[df_works$works_year &gt;= waves[[j]][1] &amp; df_works$works_year &lt;= waves[[j]][2],
                ]
            for (i in 1:nrow(df_works_w)) {
                egos = df_works_w$works_author[i][[1]]$id
                if (sum(ids %in% egos) &gt; 0) {
                  nets[j, which(ids %in% egos), which(ids %in% egos)] = 1
                }
            }
            diag(nets[j,,]) = 0
        }
    }

    output = list()
    output$data = demographics_soc
    output$nets = nets
    return(output)
}

#String uniforming function
funiform_string &lt;- function(input, numbers=TRUE, spaces=TRUE, caps=TRUE){
  string &lt;- iconv(input, from = &quot;UTF-8&quot;, to = &quot;ASCII//TRANSLIT&quot;)
  string &lt;- gsub(&#39;-&#39;,&#39;&#39;,string)
  if (numbers) string &lt;- gsub(&#39;[0-9]&#39;,&#39;&#39;,string)
  if (spaces) string &lt;- gsub(&#39; &#39;,&#39;&#39;,string)
  if (caps) string &lt;- tolower(string)
  return(string)
}

#Checking for required packages
packages = c(&quot;RSiena&quot;, &quot;devtools&quot;, &quot;igraph&quot;, &quot;tidyverse&quot;, &quot;xml2&quot;, &quot;rvest&quot;, &quot;dplyr&quot;, &quot;stringr&quot;)
fpackage.check(packages)</code></pre>
<pre class="r"><code>#First step is to scrape the ICS website for graduates and affiliates
#We want to have a list of names and two dummy variables, one for graduation and one for affiliation
#Being able to distinguish between the two will allow us to capture older sociologists who are within
  #the scope of the theory, but could not have studied at ICS because it did not exist yet

#First we get the affiliates tables from https://ics-graduateschool.nl/

#Faculty 
icsfac&lt;-read_html(&quot;https://ics-graduateschool.nl/faculty/&quot;) 
icsfac&lt;-icsfac %&gt;% html_nodes(&quot;body&quot;) %&gt;% xml_find_all(&quot;//tbody&quot;) %&gt;% html_table() 
icsfac&lt;-bind_rows(icsfac) 
icsfac$X5&lt;-&quot;Faculty&quot;

#Postdocs 
icspost&lt;-read_html(&quot;https://ics-graduateschool.nl/postdocs/&quot;) 
icspost&lt;-icspost %&gt;% html_nodes(&quot;body&quot;) %&gt;% xml_find_all(&quot;//tbody&quot;) %&gt;% html_table() 
icspost&lt;-bind_rows(icspost) 
icspost$X5&lt;-&quot;Postdoc&quot;

#PhDs 
icsphd&lt;-read_html(&quot;https://ics-graduateschool.nl/phds/&quot;) 
icsphd&lt;-icsphd %&gt;% html_nodes(&quot;body&quot;) %&gt;% xml_find_all(&quot;//tbody&quot;) %&gt;% html_table() 
icsphd&lt;-bind_rows(icsphd) 
icsphd$X5&lt;-&quot;PhD&quot;

#Merging into one table 
icsA&lt;-rbind(icsfac,icspost) 
icsA&lt;-rbind(icsA,icsphd)
icsA$icsAffiliate&lt;-1

#Making first and last names into ID variable for matching
icsA$Naam&lt;-paste(icsA$X1,icsA$X2)
icsA$Naam&lt;-funiform_string(icsA$Naam)

#Then we get the list of graduates from the same website
icsG&lt;-read_html(&quot;https://ics-graduateschool.nl/alumni-projects/&quot;)
icsG&lt;-icsG %&gt;%
  html_nodes(&quot;body&quot;) %&gt;%
  xml_find_all(&quot;//tbody&quot;) %&gt;%
  html_table()
icsG&lt;-bind_rows(icsG)
icsG$icsGraduate&lt;-1
icsG$Naam&lt;-funiform_string(icsG$X2)

#Merging the ICS affiliates and graduates tables
icsC&lt;-merge(icsA, icsG, all = TRUE, by = &quot;Naam&quot;)
icsC$unaam&lt;-icsC$Naam
icsF&lt;-icsC[c(&#39;unaam&#39;,&#39;icsAffiliate&#39;,&#39;icsGraduate&#39;)]
icsF$icsAny&lt;-1
icsF[is.na(icsF)]&lt;-0</code></pre>
<pre class="r"><code>#Second step is to load and transform the collaboration network data and merge it with the ICS data

#Loading the data
scholars&lt;-fload(&#39;C://Users/groot/Documents/RDirectory/20251016scholars.rda&#39;)

#Selecting for sociologists and transforming using the network data helper function
sndata1 = fcolnet(scholars, university = c(&#39;RU&#39;, &#39;UU&#39;, &#39;UvA&#39;, &#39;RUG&#39;, &#39;VU&#39;, &#39;UvT&#39;, &#39;EUR&#39;))
df_ego1 = bind_rows(sndata1$data)

#Adding uniformed author names to the ego level data
df_ego1$unaam&lt;-funiform_string(df_ego1$naam)

#Merging the ICS variables into the ego level data
df_ego2&lt;-merge(x=df_ego1,y=icsF,all.x=TRUE)

#Replacing missings on the ICS variables with 0 to complete the dummies
df_ego2$icsAffiliate[is.na(df_ego2$icsAffiliate)]&lt;-0
df_ego2$icsGraduate[is.na(df_ego2$icsGraduate)]&lt;-0
df_ego2$icsAny[is.na(df_ego2$icsAny)]&lt;-0</code></pre>
<pre class="r"><code>#The third step is to make the network data ready for analysis with RSiena

#Making waves
wave1 = sndata1$nets[1,,]
wave2 = sndata1$nets[2,,]
wave3 = sndata1$nets[3,,]

#Making the waves back into a single file
nets = array(
    data = c(wave1, wave2, wave3),
    dim = c(dim(wave2), 2))

#Making the RSiena nomination matrix
net = sienaDependent(nets)</code></pre>
<pre class="r"><code>#Before transforming the ego level variables into their RSiena ready form, 
#some descriptive statistics are required to ensure that strange and missing values are not carried over

#VARIABELEN DIE IK WIL: functie(ordinaal maken), universiteit, gender, ics dingen, 

#First of, the &#39;universiteit&#39; variables for each year
#These variables indicate for each sociologist in the data at which university they worked in each year

#Inspecting the variables with frequency tables
table(df_ego2$universiteit.22,useNA=&#39;always&#39;)
table(df_ego2$universiteit.24,useNA=&#39;always&#39;)
table(df_ego2$universiteit.25,useNA=&#39;always&#39;)

#The frequency tables show that there are several sociologist who work at two universities
#Some of these work at a Dutch university and a foreign one, 
#those cases are now recoded to include only the Dutch university
df_ego3&lt;-df_ego2
df_ego3$universiteit.22&lt;-gsub(&#39;EUR/Boston University&#39;, &#39;EUR&#39;, df_ego3$universiteit.22)
df_ego3$universiteit.24&lt;-gsub(&#39;EUR/Boston University&#39;, &#39;EUR&#39;, df_ego3$universiteit.24)
df_ego3$universiteit.22&lt;-gsub(&#39;RUG/TU Delft&#39;, &#39;RUG&#39;, df_ego3$universiteit.22)
df_ego3$universiteit.24&lt;-gsub(&#39;RUG/TU Delft&#39;, &#39;RUG&#39;, df_ego3$universiteit.24)
df_ego3$universiteit.22&lt;-gsub(&#39;RUG/Universiteit Stockholm&#39;, &#39;RUG&#39;, df_ego3$universiteit.22)
df_ego3$universiteit.24&lt;-gsub(&#39;RUG/Universiteit Stockholm&#39;, &#39;RUG&#39;, df_ego3$universiteit.24)
df_ego3$universiteit.22&lt;-gsub(&#39;RUG/University Linköping&#39;, &#39;RUG&#39;, df_ego3$universiteit.22)
df_ego3$universiteit.24&lt;-gsub(&#39;RUG/University Linköping&#39;, &#39;RUG&#39;, df_ego3$universiteit.24)
df_ego3$universiteit.22&lt;-gsub(&#39;RUG/University of Turku&#39;, &#39;RUG&#39;, df_ego3$universiteit.22)
df_ego3$universiteit.24&lt;-gsub(&#39;RUG/University of Turku&#39;, &#39;RUG&#39;, df_ego3$universiteit.24)
df_ego3$universiteit.22&lt;-gsub(&#39;UvA/Frankfurt School of Finance &amp; Management&#39;, &#39;UvA&#39;, df_ego3$universiteit.22)
df_ego3$universiteit.24&lt;-gsub(&#39;UvA/Frankfurt School of Finance &amp; Management&#39;, &#39;UvA&#39;, df_ego3$universiteit.24)
df_ego3$universiteit.22&lt;-gsub(&#39;UvA/University of Lausanne&#39;, &#39;UvA&#39;, df_ego3$universiteit.22)
df_ego3$universiteit.24&lt;-gsub(&#39;UvA/University of Lausanne&#39;, &#39;UvA&#39;, df_ego3$universiteit.24)
df_ego3$universiteit.22&lt;-gsub(&#39;UvT/Trento University&#39;, &#39;UvT&#39;, df_ego3$universiteit.22)
df_ego3$universiteit.24&lt;-gsub(&#39;UvT/Trento University&#39;, &#39;UvT&#39;, df_ego3$universiteit.24)
df_ego3$universiteit.22&lt;-gsub(&#39;VU/UvH&#39;, &#39;VU&#39;, df_ego3$universiteit.22)
df_ego3$universiteit.24&lt;-gsub(&#39;VU/UvH&#39;, &#39;VU&#39;, df_ego3$universiteit.24)
df_ego3$universiteit.24&lt;-gsub(&#39;RUG/University of Leipzig&#39;, &#39;RUG&#39;, df_ego3$universiteit.24)

#And make only foreign university into NA and remove question marks
df_ego3$universiteit.24&lt;-gsub(&#39;University of Cologne&#39;, NA, df_ego3$universiteit.24)
df_ego3$universiteit.24&lt;-gsub(&#39;[?]&#39;, &#39;&#39;, df_ego3$universiteit.24)

#Checking the frequencies again
table(df_ego3$universiteit.22,useNA=&#39;always&#39;)
table(df_ego3$universiteit.24,useNA=&#39;always&#39;)
table(df_ego3$universiteit.25,useNA=&#39;always&#39;)

#Now most of the cases are fine, except for the few that have two universities
#For these cases the first of the two reported universities is taken as primary,
#and is thus selected as the value of the university variable
#Loss of information was accepted in this case because adding a &#39;second university&#39; variable for 5 sociologists
#would mean changing the analysis quite substantially for what is likely to be no significant difference
df_ego3$universiteit.22&lt;-gsub(&#39;RU/RUG&#39;, &#39;RU&#39;, df_ego3$universiteit.22)
df_ego3$universiteit.24&lt;-gsub(&#39;RU/RUG&#39;, &#39;RU&#39;, df_ego3$universiteit.24)
df_ego3$universiteit.22&lt;-gsub(&#39;RUG/RU&#39;, &#39;RUG&#39;, df_ego3$universiteit.22)
df_ego3$universiteit.24&lt;-gsub(&#39;RUG/RU&#39;, &#39;RUG&#39;, df_ego3$universiteit.24)
df_ego3$universiteit.22&lt;-gsub(&#39;RUG/Tilburg&#39;, &#39;RUG&#39;, df_ego3$universiteit.22)
df_ego3$universiteit.24&lt;-gsub(&#39;RUG/Tilburg&#39;, &#39;RUG&#39;, df_ego3$universiteit.24)
df_ego3$universiteit.22&lt;-gsub(&#39;UvA/EUR&#39;, &#39;UvA&#39;, df_ego3$universiteit.22)
df_ego3$universiteit.22&lt;-gsub(&#39;UU/UvA&#39;, &#39;UU&#39;, df_ego3$universiteit.22)
df_ego3$universiteit.24&lt;-gsub(&#39;UU/UvA&#39;, &#39;UU&#39;, df_ego3$universiteit.24)

#Checking frequencies again
table(df_ego3$universiteit.22,useNA=&#39;always&#39;)
table(df_ego3$universiteit.24,useNA=&#39;always&#39;)
table(df_ego3$universiteit.25,useNA=&#39;always&#39;)

#There are no more strange values for the &#39;universiteit&#39; variables
#Now on to the &#39;functie&#39; variables, these show the sociologists&#39; job titles
table(df_ego3$functie.22,useNA=&#39;always&#39;)
table(df_ego3$functie.24,useNA=&#39;always&#39;)
table(df_ego3$functie.25,useNA=&#39;always&#39;)

#There is one slightly nondescript value here, namely &#39;staff&#39;
#For the few people with this value, 
#I decided to first see if a more informative title is given in another year, 
#then check university websites and social media
#Nine sociologist were given more informative values for the function variable this way
df_ego3$funcsub&lt;-df_ego3$functie.22
df_ego3[86,&#39;funcsub&#39;]&lt;-&#39;PhD Candidate&#39;
df_ego3[89,&#39;funcsub&#39;]&lt;-&#39;Researcher&#39;
df_ego3[143,&#39;funcsub&#39;]&lt;-&#39;Assistant Professor&#39;
df_ego3[190,&#39;funcsub&#39;]&lt;-&#39;Lecturer&#39;
df_ego3[284,&#39;funcsub&#39;]&lt;-&#39;Lecturer&#39;
df_ego3[385,&#39;funcsub&#39;]&lt;-&#39;Researcher&#39;
df_ego3[418,&#39;funcsub&#39;]&lt;-&#39;Full Professor&#39;
df_ego3[419,&#39;funcsub&#39;]&lt;-&#39;Researcher&#39;
df_ego3[431,&#39;funcsub&#39;]&lt;-&#39;Lecturer&#39;

#Check distribution
table(df_ego3$funcsub,useNA=&#39;always&#39;)

#Lastly there is the gender variable, which has five missings
table(df_ego3$gender,useNA=&#39;always&#39;)

#These missings were imputed by googling their name and the university they work at
#A picture was found for all five, gender was inferred based on gender signifiers seen in the pictures
#Main signifiers used were length of hair and presence of prominent facial hair
df_ego3[123,&#39;gender&#39;]&lt;-&#39;female&#39;
df_ego3[237,&#39;gender&#39;]&lt;-&#39;male&#39;
df_ego3[375,&#39;gender&#39;]&lt;-&#39;female&#39;
df_ego3[412,&#39;gender&#39;]&lt;-&#39;male&#39;
df_ego3[462,&#39;gender&#39;]&lt;-&#39;female&#39;

#Checking to make sure there are no more missings for gender
table(df_ego3$gender,useNA=&#39;always&#39;)

#And now the variables are ready for transformation into the form that will be used in analysis</code></pre>
<pre class="r"><code>#Now to transform the three ego level variables from the original data

#Starting with &#39;university&#39;
#I want there to be one variable indicating the university each sociologist is most affiliated with
#By most affiliated I mainly mean how long they were affiliated with a university, so where they would have
#spent the most time and presumably, as is most relevant, collaborated most
#As such, the basis for the &#39;university&#39; variable will be the &#39;universiteit.22&#39; variable, with any missing
#values on this variable being supplemented first with &#39;universiteit.24&#39; and then &#39;universiteit.25&#39; if needed

#In order to do this, the universities with three letter abbreviations are abbreviated to two letters
#2022
df_ego3$uni22&lt;-df_ego3$universiteit.22
df_ego3$uni22&lt;-gsub(&#39;EUR&#39;,&#39;EU&#39;,df_ego3$uni22)
df_ego3$uni22&lt;-gsub(&#39;RUG&#39;,&#39;UG&#39;,df_ego3$uni22)
df_ego3$uni22&lt;-gsub(&#39;UvA&#39;,&#39;UA&#39;,df_ego3$uni22)
df_ego3$uni22&lt;-gsub(&#39;UvT&#39;,&#39;UT&#39;,df_ego3$uni22)

#2024
df_ego3$uni24&lt;-df_ego3$universiteit.24
df_ego3$uni24&lt;-gsub(&#39;EUR&#39;,&#39;EU&#39;,df_ego3$uni24)
df_ego3$uni24&lt;-gsub(&#39;RUG&#39;,&#39;UG&#39;,df_ego3$uni24)
df_ego3$uni24&lt;-gsub(&#39;UvA&#39;,&#39;UA&#39;,df_ego3$uni24)
df_ego3$uni24&lt;-gsub(&#39;UvT&#39;,&#39;UT&#39;,df_ego3$uni24)

#2025
df_ego3$uni25&lt;-df_ego3$universiteit.25
df_ego3$uni25&lt;-gsub(&#39;EUR&#39;,&#39;EU&#39;,df_ego3$uni25)
df_ego3$uni25&lt;-gsub(&#39;RUG&#39;,&#39;UG&#39;,df_ego3$uni25)
df_ego3$uni25&lt;-gsub(&#39;UvA&#39;,&#39;UA&#39;,df_ego3$uni25)
df_ego3$uni25&lt;-gsub(&#39;UvT&#39;,&#39;UT&#39;,df_ego3$uni25)

#Check if this worked
table(df_ego3$uni22,df_ego3$universiteit.22,useNA=&#39;always&#39;)
table(df_ego3$uni24,df_ego3$universiteit.24,useNA=&#39;always&#39;)
table(df_ego3$uni25,df_ego3$universiteit.25,useNA=&#39;always&#39;)

#This worked, all universities now use two letter abbreviations
#Now to make one variable which includes only the earliest university available for each sociologist
df_ego3$university&lt;-paste(df_ego3$uni22,df_ego3$uni24,df_ego3$uni25)
df_ego3$university&lt;-gsub(&#39;NA&#39;,&#39;&#39;,df_ego3$university)
df_ego3$university&lt;-gsub(&#39; &#39;,&#39;&#39;,df_ego3$university)
df_ego3$university&lt;-substr(df_ego3$university,start=1,stop=2)

#Check if this worked by inspecting a list
universityCheck&lt;-cbind.data.frame(df_ego3$uni22,df_ego3$uni24,df_ego3$uni25,df_ego3$university)
view(universityCheck)
rm(universityCheck)

#Distribution of the new &#39;university&#39; variable
table(df_ego3$university,useNA=&#39;always&#39;)

#Now as a final transformation, the variable will be made numeric for use in RSiena
df_ego3$universityN&lt;-df_ego3$university
df_ego3$universityN&lt;-gsub(&#39;EU&#39;,0,df_ego3$universityN)
df_ego3$universityN&lt;-gsub(&#39;RU&#39;,1,df_ego3$universityN)
df_ego3$universityN&lt;-gsub(&#39;UA&#39;,2,df_ego3$universityN)
df_ego3$universityN&lt;-gsub(&#39;UG&#39;,3,df_ego3$universityN)
df_ego3$universityN&lt;-gsub(&#39;UT&#39;,4,df_ego3$universityN)
df_ego3$universityN&lt;-gsub(&#39;UU&#39;,5,df_ego3$universityN)
df_ego3$universityN&lt;-gsub(&#39;VU&#39;,6,df_ego3$universityN)

#Final check
table(df_ego3$university,df_ego3$universityN)</code></pre>
<pre class="r"><code>#The next variable to transform is &#39;function&#39;
#The same logic is applied here, the goal is one variable which indicates which function each sociologist had
#The 2022 function is preferred to 2024 and 2025 functions, again with the argument that any changes in function
#which occured this year (2025) or last year (2024) compared to 2022 would have had less of an effect on the 
#publication record and collaborations of each sociologist than the function they had in 2022.

#Because of the more heterogenous string length of the function variables as compared to the university 
#variables, they are first made into numbers, then combined, then the first is selected, which is then
#transformed back into the original string

#Making the function variables into numbers
#2022 (funcsub is used because it has the imputed missings)
df_ego3$func22&lt;-df_ego3$funcsub
df_ego3$func22&lt;-gsub(&#39;PhD Candidate&#39;,&#39;0&#39;,df_ego3$func22)
df_ego3$func22&lt;-gsub(&#39;Postdoctoral Researcher&#39;,&#39;1&#39;,df_ego3$func22)
df_ego3$func22&lt;-gsub(&#39;Lecturer&#39;,&#39;2&#39;,df_ego3$func22)
df_ego3$func22&lt;-gsub(&#39;Researcher&#39;,&#39;3&#39;,df_ego3$func22)
df_ego3$func22&lt;-gsub(&#39;Assistant Professor&#39;,&#39;4&#39;,df_ego3$func22)
df_ego3$func22&lt;-gsub(&#39;Associate Professor&#39;,&#39;5&#39;,df_ego3$func22)
df_ego3$func22&lt;-gsub(&#39;Full Professor&#39;,&#39;6&#39;,df_ego3$func22)

#2024
df_ego3$func24&lt;-df_ego3$functie.24
df_ego3$func24&lt;-gsub(&#39;PhD Candidate&#39;,&#39;0&#39;,df_ego3$func24)
df_ego3$func24&lt;-gsub(&#39;Postdoctoral Researcher&#39;,&#39;1&#39;,df_ego3$func24)
df_ego3$func24&lt;-gsub(&#39;Lecturer&#39;,&#39;2&#39;,df_ego3$func24)
df_ego3$func24&lt;-gsub(&#39;Researcher&#39;,&#39;3&#39;,df_ego3$func24)
df_ego3$func24&lt;-gsub(&#39;Assistant Professor&#39;,&#39;4&#39;,df_ego3$func24)
df_ego3$func24&lt;-gsub(&#39;Associate Professor&#39;,&#39;5&#39;,df_ego3$func24)
df_ego3$func24&lt;-gsub(&#39;Full Professor&#39;,&#39;6&#39;,df_ego3$func24)

#2025
df_ego3$func25&lt;-df_ego3$functie.25
df_ego3$func25&lt;-gsub(&#39;PhD Candidate&#39;,&#39;0&#39;,df_ego3$func25)
df_ego3$func25&lt;-gsub(&#39;Postdoctoral Researcher&#39;,&#39;1&#39;,df_ego3$func25)
df_ego3$func25&lt;-gsub(&#39;Lecturer&#39;,&#39;2&#39;,df_ego3$func25)
df_ego3$func25&lt;-gsub(&#39;Researcher&#39;,&#39;3&#39;,df_ego3$func25)
df_ego3$func25&lt;-gsub(&#39;Assistant Professor&#39;,&#39;4&#39;,df_ego3$func25)
df_ego3$func25&lt;-gsub(&#39;Associate Professor&#39;,&#39;5&#39;,df_ego3$func25)
df_ego3$func25&lt;-gsub(&#39;Full Professor&#39;,&#39;6&#39;,df_ego3$func25)

#Check values if the values correspond
functionCheck&lt;-cbind.data.frame(
  df_ego3$funcsub,df_ego3$func22,df_ego3$functie.24,df_ego3$func24,df_ego3$functie.25,df_ego3$func25)
view(functionCheck)
rm(functionCheck)

#The values are as intended, now to merge the numbers, extract the first and make it back into a word
df_ego3$functionN&lt;-paste(df_ego3$func22,df_ego3$func24,df_ego3$func25)
df_ego3$functionN&lt;-gsub(&#39;NA&#39;,&#39;&#39;,df_ego3$functionN)
df_ego3$functionN&lt;-gsub(&#39; &#39;,&#39;&#39;,df_ego3$functionN)
df_ego3$functionN&lt;-substr(df_ego3$functionN,start=1,stop=1)
table(df_ego3$functionN,useNA=&#39;always&#39;)

#Now to make the variable actually numeric
df_ego3$functionN&lt;-gsub(&#39;0&#39;,0,df_ego3$functionN)
df_ego3$functionN&lt;-gsub(&#39;1&#39;,1,df_ego3$functionN)
df_ego3$functionN&lt;-gsub(&#39;2&#39;,2,df_ego3$functionN)
df_ego3$functionN&lt;-gsub(&#39;3&#39;,3,df_ego3$functionN)
df_ego3$functionN&lt;-gsub(&#39;4&#39;,4,df_ego3$functionN)
df_ego3$functionN&lt;-gsub(&#39;5&#39;,5,df_ego3$functionN)
df_ego3$functionN&lt;-gsub(&#39;6&#39;,6,df_ego3$functionN)
table(df_ego3$functionN,useNA=&#39;always&#39;)

#And create a string version for easy reference
df_ego3$functionS&lt;-df_ego3$functionN
df_ego3$functionS&lt;-gsub(&#39;0&#39;,&#39;PhD Candidate&#39;,df_ego3$functionS)
df_ego3$functionS&lt;-gsub(&#39;1&#39;,&#39;Postdoctoral Researcher&#39;,df_ego3$functionS)
df_ego3$functionS&lt;-gsub(&#39;2&#39;,&#39;Lecturer&#39;,df_ego3$functionS)
df_ego3$functionS&lt;-gsub(&#39;3&#39;,&#39;Researcher&#39;,df_ego3$functionS)
df_ego3$functionS&lt;-gsub(&#39;4&#39;,&#39;Assistant Professor&#39;,df_ego3$functionS)
df_ego3$functionS&lt;-gsub(&#39;5&#39;,&#39;Associate Professor&#39;,df_ego3$functionS)
df_ego3$functionS&lt;-gsub(&#39;6&#39;,&#39;Full Professor&#39;,df_ego3$functionS)
table(df_ego3$functionS,useNA=&#39;always&#39;)

#Check if the values are correct
functionCheck&lt;-cbind.data.frame(
  df_ego3$funcsub,df_ego3$func22,df_ego3$functie.24,df_ego3$func24,df_ego3$functie.25,df_ego3$func25,
  df_ego3$functionN,df_ego3$functionS)
view(functionCheck)
rm(functionCheck)

#Turns out there are still 13 missings, these are marked NA
df_ego3[46,&#39;functionN&#39;]&lt;-NA
df_ego3[46,&#39;functionS&#39;]&lt;-NA
df_ego3[125,&#39;functionN&#39;]&lt;-NA
df_ego3[125,&#39;functionS&#39;]&lt;-NA
df_ego3[174,&#39;functionN&#39;]&lt;-NA
df_ego3[174,&#39;functionS&#39;]&lt;-NA
df_ego3[188,&#39;functionN&#39;]&lt;-NA
df_ego3[188,&#39;functionS&#39;]&lt;-NA
df_ego3[195,&#39;functionN&#39;]&lt;-NA
df_ego3[195,&#39;functionS&#39;]&lt;-NA
df_ego3[237,&#39;functionN&#39;]&lt;-NA
df_ego3[237,&#39;functionS&#39;]&lt;-NA
df_ego3[248,&#39;functionN&#39;]&lt;-NA
df_ego3[248,&#39;functionS&#39;]&lt;-NA
df_ego3[274,&#39;functionN&#39;]&lt;-NA
df_ego3[274,&#39;functionS&#39;]&lt;-NA
df_ego3[324,&#39;functionN&#39;]&lt;-NA
df_ego3[324,&#39;functionS&#39;]&lt;-NA
df_ego3[355,&#39;functionN&#39;]&lt;-NA
df_ego3[355,&#39;functionS&#39;]&lt;-NA
df_ego3[375,&#39;functionN&#39;]&lt;-NA
df_ego3[375,&#39;functionS&#39;]&lt;-NA
df_ego3[403,&#39;functionN&#39;]&lt;-NA
df_ego3[403,&#39;functionS&#39;]&lt;-NA
df_ego3[457,&#39;functionN&#39;]&lt;-NA
df_ego3[457,&#39;functionS&#39;]&lt;-NA

#Check again
table(df_ego3$functionN,df_ego3$functionS,useNA=&#39;always&#39;)

#Now the string and numeric function variables are as intended</code></pre>
<pre class="r"><code>#Lastly the gender variable was made into a dummy
df_ego3$genderN&lt;-df_ego3$gender
df_ego3$genderN&lt;-gsub(&#39;female&#39;,0,df_ego3$genderN)
df_ego3$genderN&lt;-gsub(&#39;male&#39;,1,df_ego3$genderN)

#Check if the values correspond to the original variable
table(df_ego3$gender,df_ego3$genderN,useNA=&#39;always&#39;)

#They do, the gender dummy is made</code></pre>
<pre class="r"><code>#The last step is to ensure there are no duplicate cases in the dataset and delete any remaining missings
table(df_ego3$unaam)

#There are a few duplicates, they are removed
df_egoF&lt;-df_ego3[!duplicated(df_ego3[c(&#39;unaam&#39;)]), ]

#Checking for missings in our key variables
table(df_ego3$genderN,useNA=&#39;always&#39;)
table(df_ego3$functionN,useNA=&#39;always&#39;)
table(df_ego3$universityN,useNA=&#39;always&#39;)
table(df_ego3$icsAffiliate,useNA=&#39;always&#39;)
table(df_ego3$icsGraduate,useNA=&#39;always&#39;)
table(df_ego3$icsAny,useNA=&#39;always&#39;)

#There are still 13 sociologists with a missing value for the function variable, they are deleted listwise
#df_egoF&lt;-df_ego3[!is.na(df_ego3[c(&#39;functionN&#39;)]), ]
#sienaDataCreate doesnt work if you delete missings listwise, function was a robustness check anyways

#Now we have the final ego level variable dataframe, df_egoF</code></pre>
<pre class="r"><code>#With the data cleaned, it can now be made into an RSiena data object
#Some still need to be marked as numeric, which does not change the values in this case
df_egoF$universityN&lt;-as.numeric(df_egoF$universityN)
universityN&lt;-coCovar(df_egoF$universityN,centered=FALSE)
df_egoF$functionN&lt;-as.numeric(df_egoF$functionN)
functionO&lt;-coCovar(df_egoF$functionN,centered=FALSE)
df_egoF$genderN&lt;-as.numeric(df_egoF$genderN)
genderD&lt;-coCovar(df_egoF$genderN,centered=FALSE)
icsanyD&lt;-coCovar(df_egoF$icsAny,centered=FALSE)
icsaffilD&lt;-coCovar(df_egoF$icsAffiliate,centered=FALSE)
icsgradD&lt;-coCovar(df_egoF$icsGraduate,centered=FALSE)

#Making the data object
collabnet1&lt;-sienaDataCreate(net, universityN, functionO, genderD, icsanyD, icsaffilD, icsgradD)
print01Report(collabnet1)

#Create main algorithm
algoMain&lt;-sienaAlgorithmCreate()

#Now to specify the models

#A first model including only icsany
effects1&lt;-getEffects(collabnet1)
#Effects of ego characteristics
  effects1&lt;-includeEffects(effects1,sameX,name=&#39;net&#39;,interaction1=&#39;icsanyD&#39;)

#Estimate model 1
testEstimate1&lt;-siena07(algoMain,data=collabnet1,effects=effects1,returnDeps=TRUE)
testEstimate1
  
#A second model including icsany and the three controls
effects2&lt;-getEffects(collabnet1)
#Effects of ego characteristics
  effects2&lt;-includeEffects(effects2,sameX,name=&#39;net&#39;,interaction1=&#39;genderD&#39;)
  effects2&lt;-includeEffects(effects2,sameX,name=&#39;net&#39;,interaction1=&#39;universityN&#39;)
  effects2&lt;-includeEffects(effects2,sameX,name=&#39;net&#39;,interaction1=&#39;icsanyD&#39;)
  effects2&lt;-includeEffects(effects2,unequalX,name=&#39;net&#39;,interaction1=&#39;functionO&#39;)
  
#Estimate model 2
  testEstimate2&lt;-siena07(algoMain,data=collabnet1,effects=effects2,returnDeps=TRUE)
  testEstimate2
  
#A third model including the two separate ics variables and controls
effects3&lt;-getEffects(collabnet1)
#Effects of ego characteristics
  effects3&lt;-includeEffects(effects3,sameX,name=&#39;net&#39;,interaction1=&#39;genderD&#39;)
  effects3&lt;-includeEffects(effects3,sameX,name=&#39;net&#39;,interaction1=&#39;universityN&#39;)
  effects3&lt;-includeEffects(effects3,sameX,name=&#39;net&#39;,interaction1=&#39;icsaffilD&#39;)
  effects3&lt;-includeEffects(effects3,sameX,name=&#39;net&#39;,interaction1=&#39;icsgradD&#39;)
  effects3&lt;-includeEffects(effects3,unequalX,name=&#39;net&#39;,interaction1=&#39;functionO&#39;)
  
#Estimate model 3
  testEstimate3&lt;-siena07(algoMain,data=collabnet1,effects=effects3,returnDeps=TRUE)
  testEstimate3</code></pre>
<pre class="r"><code>#Goodness of Fit of first two model attempts

#Attempt 1, with only icsany
model1gof1 &lt;- sienaGOF(testEstimate1, IndegreeDistribution, verbose = FALSE, join = TRUE, varName = &quot;net&quot;)
model1gof1
plot(model1gof1)

#Attempt 2, with icsany and structural effects
model2gof1 &lt;- sienaGOF(testEstimate2, IndegreeDistribution, verbose = FALSE, join = TRUE, varName = &quot;net&quot;)
model2gof1
plot(model2gof1)

#Attempt 3, with separate ics variables and controls
model3gof1 &lt;- sienaGOF(testEstimate3, IndegreeDistribution, verbose = FALSE, join = TRUE, varName = &quot;net&quot;)
model3gof1
plot(model3gof1)</code></pre>
<pre class="r"><code>#For the definitive model, a relative influence analysis is useful to compare the effects</code></pre>
<pre class="r"><code>#Visualising the network

#V1 With isolates
netvis1 &lt;- igraph::graph_from_adjacency_matrix(
  sndata1$nets[2,,],
  mode = c(&quot;directed&quot;),
  weighted = NULL,
  diag = FALSE,
  add.colnames = NULL,)

plot(netvis1,
  vertex.color = ifelse(dfNiso$icsAny == 1, &quot;red&quot;, &quot;blue&quot;),
  vertex.label = NA,
  vertex.size = 5,
  edge.width = 0.2,
  edge.arrow.size =0.2)

#V2 Without isolates
noisolates = rowSums(sndata1$nets[2,,]) &gt; 0
netNiso = sndata1$nets[2,noisolates,noisolates]
dfNiso = df_egoF[noisolates, ]

netvis2 &lt;- igraph::graph_from_adjacency_matrix(
  netNiso,
  mode = c(&quot;directed&quot;),
  weighted = NULL,
  diag = FALSE,
  add.colnames = NULL,)

plot(netvis2,
  vertex.color = ifelse(dfNiso$icsAny == 1, &quot;red&quot;, &quot;blue&quot;),
  vertex.label = NA,
  vertex.size = 5,
  edge.width = 0.2,
  edge.arrow.size =0.2)</code></pre>
<pre class="r"><code>#Now to test whether the network has a significant amount of clustering
#First calculate the global clustering coefficient and transitivity ratio for our network
#Then simulate networks without clustering
#Then see if our values are significantly higher

#Calculating the clustering coefficient
transitivity(netvis2)
transitivity(netvis2,type=&#39;average&#39;)

#Specifying the models to simulate based on the final RSiena model
effectsSim&lt;-effects#
  effectsSim&lt;-includeEffects(effectsSim,StrEFFECT,initialValue = 
                               MODEL$theta[which(MODEL$effects$shortName == &quot;StrEFFECT&quot;)]))
  effectsSim&lt;-includeEffects(effectsSim,EgoEFFECT,interaction1=&#39;VARIABLE&#39;,initialValue = 
                               MODEL$theta[which(MODEL$effects$shortName == &quot;EgoEFFECT&quot;)]))

#Fix effects of all variables
effectsSim$fix[effectsSim$include == TRUE] &lt;- TRUE

#Introduce higher and no effect variations
effectsSim0 &lt;- effectsSimHI &lt;- effectsSim

#Adjust CONTROLLED VARIABLE effect in alt simulations
effectsSim0 &lt;- setEffect(effectsSim, EFFECT, initialValue = 0, fix = TRUE)
effectsSimHI &lt;- setEffect(effectsSim, EFFECT, initialValue = 
                            MODEL$theta[which(MODEL$effects$shortName == &quot;EFFECT&quot;)] * 2, fix = TRUE)

#Make simulation algorithm
iterSim&lt;-1000
algoSim &lt;- sienaAlgorithmCreate(
    projname = &#39;simulation&#39;,
    cond = FALSE,
    useStdInits = FALSE, nsub = 0,
    n3 = iterSim, 
    seed=242452, # seed for replication
    simOnly = TRUE)</code></pre>
<pre class="r"><code>#Carrying out the simulations and storing both transitivity indices for use as clustering indicators
#Make vector to store transitivity

transSimG &lt;- transSimG0 &lt;- transSimGHI &lt;- rep(0, iterSim)
transSimA &lt;- transSimA0 &lt;- transSimAHI &lt;- rep(0, iterSim)

#Simulations using estimated parameters
simObs &lt;- siena07(algoSim,      # simulation settings
                   data = collabnet1,      # data
                   effects = effectsSim,# defined effects and set parameters
                   returnDeps = TRUE)  # return simulated networks
  
sim0 &lt;- siena07(algoSim,       # simulation settings
                   data = collabnet1,      # data
                   effects = effectsSim0,# defined effects and set parameters
                   returnDeps = TRUE)  # return simulated networks
  
simHI &lt;- siena07(algoSim,     # simulation settings
                   data = collabnet1,      # data
                   effects = effectsSimHI,# defined effects and set parameters
                   returnDeps = TRUE)  # return simulated networks</code></pre>
<pre class="r"><code>#Extract transitivity from simulation runs

#Set n
n&lt;-length(collabnet1$nodeSets[[1]]) 

#Observed model
for (i in 1:iterSim) { 
  #Create adjacency matrix
  adj &lt;- matrix(0, n, n)
  edges &lt;- simObs$sims[[i]][[1]][[1]][[1]]
  adj[edges[, 1:2]] &lt;- edges[, 3]
  
  #Create igraph object
  graphSim &lt;- igraph::graph_from_adjacency_matrix(
  adj[2,,],
  mode = c(&quot;directed&quot;),
  weighted = NULL,
  diag = FALSE,
  add.colnames = NULL,)
  
  #Calculate and store global and average transitivity
  transSimG[i]&lt;-transitivity(graphSim)
  transSimA[i]&lt;-transitivity(graphSim, type=&#39;average&#39;)
}

#No ICS sameX model
for (i in 1:iterSim) { 
  #Create adjacency matrix
  adj &lt;- matrix(0, n, n)
  edges &lt;- sim0$sims[[i]][[1]][[1]][[1]]
  adj[edges[, 1:2]] &lt;- edges[, 3]
  
  #Create igraph object
  graphSim &lt;- igraph::graph_from_adjacency_matrix(
  adj[2,,],
  mode = c(&quot;directed&quot;),
  weighted = NULL,
  diag = FALSE,
  add.colnames = NULL,)
  
  #Calculate and store global and average transitivity
  transSimG0[i]&lt;-transitivity(graphSim)
  transSimA0[i]&lt;-transitivity(graphSim, type=&#39;average&#39;)
}


#High ICS sameX model
for (i in 1:iterSim) { 
  #Create adjacency matrix
  adj &lt;- matrix(0, n, n)
  edges &lt;- simHI$sims[[i]][[1]][[1]][[1]]
  adj[edges[, 1:2]] &lt;- edges[, 3]
  
  #Create igraph object
  graphSim &lt;- igraph::graph_from_adjacency_matrix(
  adj[2,,],
  mode = c(&quot;directed&quot;),
  weighted = NULL,
  diag = FALSE,
  add.colnames = NULL,)
  
  #Calculate and store global and average transitivity
  transSimGHI[i]&lt;-transitivity(graphSim)
  transSimAHI[i]&lt;-transitivity(graphSim, type=&#39;average&#39;)
}

#Summarise for plotting, first global transitivity
simDataG &lt;- data.frame(condition = c(rep(&quot;ObsICS&quot;, iterSim), rep(&quot;0ICS&quot;, iterSim), rep(&quot;HIICS&quot;, iterSim)),
                       transG = c(transSimG, transSimG0, transSimGHI))
simDataG$condition &lt;- factor(simDataG$condition, levels = c(&quot;ObsICS&quot;, &quot;0ICS&quot;, &quot;HIICS&quot;))

#Then average transitivity
simDataA &lt;- data.frame(condition = c(rep(&quot;ObsICS&quot;, iterSim), rep(&quot;0ICS&quot;, iterSim), rep(&quot;HIICS&quot;, iterSim)),
                       transA = c(transSimA, transSimA0, transSimAHI))
simDataA$condition &lt;- factor(simDataA$condition, levels = c(&quot;ObsICS&quot;, &quot;0ICS&quot;, &quot;HIICS&quot;))

#Plotting
transGplot &lt;- ggplot(simDataG, aes(x = condition, y = transG)) +
  geom_boxplot() +
  labs(title = &quot;Distribution of global transitivity over 1000 iterations, across simulation models&quot;,
       x = &quot;simulation model&quot;,
       y = &quot;transG&quot;) +
  ylim(0,1) +
  theme_minimal()

transAplot &lt;- ggplot(simDataA, aes(x = condition, y = transA)) +
  geom_boxplot() +
  labs(title = &quot;Distribution of average transitivity over 1000 iterations, across simulation models&quot;,
       x = &quot;simulation model&quot;,
       y = &quot;transA&quot;) +
  ylim(0,1) +
  theme_minimal()</code></pre>

<div id="rmd-source-code">LS0tDQp0aXRsZTogIkRhdGFwcmVwRmluYWwiDQphdXRob3I6ICJUamV1IEdyb290aHVpanNlbiINCmRhdGU6ICIyMDI1LTEwLTE3Ig0Kb3V0cHV0OiBodG1sX2RvY3VtZW50DQotLS0NCg0KYGBge3Igc2V0dXAsIGluY2x1ZGU9RkFMU0V9DQprbml0cjo6b3B0c19jaHVuayRzZXQoZWNobyA9IFRSVUUpDQpgYGANCi0tLQ0KVGhpcyBwYWdlIGRvY3VtZW50cyB0aGUgcHJlcGFyYXRpb24gb2YgdGhlIGRhdGEgZm9yIHVzZSBpbiB0aGUgZmluYWwgYXNzaWdubWVudC4NCkV2ZXJ5dGhpbmcgaXMgcGxhY2VkIGluIG9yZGVyIG9mIHdoZW4gSSBkaWQgaXQsIG1vc3RseSBhcyBhIHJlZmVyZW5jZSBmb3IgbXlzZWxmLg0KQWxsIG9mIHRoaXMgc3R1ZmYgaXMgbW9yZSBuZWF0bHkgaW50ZWdyYXRlZCBpbiB0aGUgZmluYWwgYXNzaWdubWVudCBwYWdlcy4NCg0KVGhlIGZvbGxvd2luZyBzdGVwcyBhcmUgdGFrZW4gdG8gbWFrZSB0aGUgZGF0YSBzdWl0YWJsZSBmb3IgYXNzZXNzaW5nIHdoZXRoZXIgY2x1c3RlcmluZyBpbiB0aGUNCmNvbGxhYm9yYXRpb24gbmV0d29yayBvZiBzb2Npb2xvZ2lzdHMgaW4gdGhlIE5ldGhlcmxhbmRzIG9jY3VycyBkdWUgdG8gcHJlZmVyZW50aWFsIGF0dGFjaG1lbnQNCnRvIGNvbGxlYWd1ZXMgd2hvIGF0dGVuZGVkIHRoZSBzYW1lIGdyYWR1YXRlIHNjaG9vbC4gDQpGb3Igbm93LCBJIGFtIG9ubHkgZGlzdGluZ3Vpc2hpbmcgSUNTIGluc3RlYWQgb2YgaW5jbHVkaW5nIGFsbCBncmFkdWF0ZSBzY2hvb2xzLg0KVGhpcyBpcyBiZWNhdXNlIHRoZSBJQ1MgZGF0YSBpcyBlYXNpbHkgb2J0YWluZWQgYW5kIGluY2x1ZGVzIGEgbGFyZ2UgcHJvcG9ydGlvbiBvZiBzb2Npb2xvZ2lzdHMuDQpJZiB0aGUgcHJvcG9ydGlvbiBvZiBzb2Npb2xvZ2lzdHMgYWZmaWxpYXRlZCB3aXRoIElDUyB0dXJucyBvdXQgdG8gYmUgdG9vIGxvdywgbW9yZSBkYXRhIHdpbGwgYmUgc291Z2h0Lg0KDQpQbGFuOg0KMS4gTG9hZGluZyBuZWNjZXNhcnkgcGFja2FnZXMgYW5kIGZ1bmN0aW9ucw0KMi4gV2Vic2NyYXBlIGRhdGEgYWJvdXQgZ3JhZHVhdGVzIGFuZCBhZmZpbGlhdGVzIGZyb20gdGhlIElDUyB3ZWJzaXRlLCBtYWtlIHRoZXNlIGludG8gYSBsaXN0IG9mIG5hbWVzDQozLiBMb2FkICdzY2hvbGFycycgZGF0YSBjb250YWluaW5nIHRoZSBzb2Npb2xvZ2lzdHMgYW5kIGNvbGxhYm9yYXRpb25zLCByZW1vdmUgcG9saXNjaSBhbmQgaXJyZWxldmFudCB2YXJpYWJsZXMNCjQuIE1hdGNoIGxpc3Qgb2YgSUNTIGFmZmlsaWF0ZXMgdG8gc2Nob2xhcnMgZGF0YSB1c2luZyBuYW1lcw0KNS4gTWFrZSBtZXJnZWQgZGF0YXNldCBzdWl0YWJsZSBmb3IgYW5hbHlzaXMgd2l0aCBSU2llbmENCjYuIEFuYWx5c2UgZGVzY3JpcHRpdmUgc3RhdGlzdGljcw0KDQpgYGB7cixldmFsPUZ9DQojTG9hZGluZyBpbiB0aGUgbmVjZXNzYXJ5IHBhY2thZ2VzIGFuZCBkZWZpbmluZyBmdW5jdGlvbnMNCiNFbXB0aWVzIHlvdXIgZW52aXJvbm1lbnQsIHJlbW92ZSBoYXNoIG9ubHkgaWYgeW91IGFyZSBzdXJlIGV2ZXJ5dGhpbmcgaW1wb3J0YW50IGlzIHNhdmVkIQ0KI3JtKGxpc3QgPSBscygpKQ0KDQojRGVmaW5pbmcgY3VzdG9tIGZ1bmN0aW9ucw0KDQojSm9jaGVtcyBmdW5jdGlvbnMNCiNmcGFja2FnZS5jaGVjazogQ2hlY2sgaWYgcGFja2FnZXMgYXJlIGluc3RhbGxlZCAoYW5kIGluc3RhbGwgaWYgbm90KSBpbiBSDQpmcGFja2FnZS5jaGVjayA8LSBmdW5jdGlvbihwYWNrYWdlcykgew0KICAgIGxhcHBseShwYWNrYWdlcywgRlVOID0gZnVuY3Rpb24oeCkgew0KICAgICAgICBpZiAoIXJlcXVpcmUoeCwgY2hhcmFjdGVyLm9ubHkgPSBUUlVFKSkgew0KICAgICAgICAgICAgaW5zdGFsbC5wYWNrYWdlcyh4LCBkZXBlbmRlbmNpZXMgPSBUUlVFKQ0KICAgICAgICAgICAgbGlicmFyeSh4LCBjaGFyYWN0ZXIub25seSA9IFRSVUUpDQogICAgICAgIH0NCiAgICB9KQ0KfQ0KDQojZnNhdmU6IFNhdmUgdG8gcHJvY2Vzc2VkIGRhdGEgaW4gcmVwb3NpdG9yeQ0KZnNhdmUgPC0gZnVuY3Rpb24oeCwgZmlsZSA9IE5VTEwsIGxvY2F0aW9uID0gIi4vZGF0YS9wcm9jZXNzZWQvIikgew0KICAgIGlmZWxzZSghZGlyLmV4aXN0cygiZGF0YSIpLCBkaXIuY3JlYXRlKCJkYXRhIiksIEZBTFNFKQ0KICAgIGlmZWxzZSghZGlyLmV4aXN0cygiZGF0YS9wcm9jZXNzZWQiKSwgZGlyLmNyZWF0ZSgiZGF0YS9wcm9jZXNzZWQiKSwgRkFMU0UpDQogICAgaWYgKGlzLm51bGwoZmlsZSkpDQogICAgICAgIGZpbGUgPSBkZXBhcnNlKHN1YnN0aXR1dGUoeCkpDQogICAgZGF0ZW5hbWUgPC0gc3Vic3RyKGdzdWIoIls6LV0iLCAiIiwgU3lzLnRpbWUoKSksIDEsIDgpDQogICAgdG90YWxuYW1lIDwtIHBhc3RlKGxvY2F0aW9uLCBkYXRlbmFtZSwgZmlsZSwgIi5yZGEiLCBzZXAgPSAiIikNCiAgICBzYXZlKHgsIGZpbGUgPSB0b3RhbG5hbWUpICAjbmVlZCB0byBmaXggaWYgZmlsZSBpcyByZWxvYWRlZCBhcyBpbnB1dCBuYW1lLCBub3QgYXMgeC4gDQp9DQoNCiNmbG9hZDogVG8gbG9hZCB0aGUgZmlsZXMgYmFjayBhZnRlciBhbiBmc2F2ZQ0KZmxvYWQgPC0gZnVuY3Rpb24oZmlsZW5hbWUpIHsNCiAgICBsb2FkKGZpbGVuYW1lKQ0KICAgIGdldChscygpW2xzKCkgIT0gImZpbGVuYW1lIl0pDQp9DQoNCiNmc2hvd2RmOiBUbyBwcmludCBvYmplY3RzICh0aWJibGVzIC8gZGF0YS5mcmFtZSkgbmljZWx5IG9uIHNjcmVlbiBpbiAucm1kDQpmc2hvd2RmIDwtIGZ1bmN0aW9uKHgsIC4uLikgew0KICAgIGtuaXRyOjprYWJsZSh4LCBkaWdpdHMgPSAyLCAiaHRtbCIsIC4uLikgJT4lDQogICAgICAgIGthYmxlRXh0cmE6OmthYmxlX3N0eWxpbmcoYm9vdHN0cmFwX29wdGlvbnMgPSBjKCJzdHJpcGVkIiwgImhvdmVyIikpICU+JQ0KICAgICAgICBrYWJsZUV4dHJhOjpzY3JvbGxfYm94KHdpZHRoID0gIjEwMCUiLCBoZWlnaHQgPSAiMzAwcHgiKQ0KfQ0KDQojTmV0d29yayBkYXRhIGhlbHBlciBmdW5jdGlvbg0KZmNvbG5ldCA9IGZ1bmN0aW9uKGRhdGEgPSBzY2hvbGFycywgdW5pdmVyc2l0eSA9IGMoIlJVIiwgJ1VVJyksIGRpc2NpcGxpbmUgPSAiU29jaW9sb2dpZSIsIHdhdmVzID0gbGlzdChjKDIwMTUsDQogICAgMjAxOCksIGMoMjAxOSwgMjAyMyksIGMoMjAyNCwgMjAyNSkpLCB0eXBlID0gYygiZmlyc3QiKSkgew0KDQogICAgdW5pdmVyc2l0eSA9IHBhc3RlMCgnKCcsIHBhc3RlMCh1bml2ZXJzaXR5LCBjb2xsYXBzZT0nfCcgKSwgJyknKQ0KICAgIGRpc2NpcGxpbmUgPSBwYXN0ZTAoJygnLCBwYXN0ZTAoZGlzY2lwbGluZSwgY29sbGFwc2U9J3wnICksICcpJykNCg0KICAgICMgc3RlcCAxDQogICAgZGVtb2dyYXBoaWNzID0gZGF0YSRkZW1vZ3JhcGhpY3MNCiAgICBzYW1wbGUgPSB3aGljaCgNCiAgICAgICAgKHN0cl9kZXRlY3QoZGVtb2dyYXBoaWNzJHVuaXZlcnNpdGVpdC4yMiwgdW5pdmVyc2l0eSkNCiAgICAgICAgICAgIHwgc3RyX2RldGVjdChkZW1vZ3JhcGhpY3MkdW5pdmVyc2l0ZWl0LjI0LCB1bml2ZXJzaXR5KQ0KICAgICAgICAgICAgfCBzdHJfZGV0ZWN0KGRlbW9ncmFwaGljcyR1bml2ZXJzaXRlaXQuMjUsIHVuaXZlcnNpdHkpDQogICAgICAgICkgJiAoDQogICAgICAgICAgICBzdHJfZGV0ZWN0KGRlbW9ncmFwaGljcyRkaXNjaXBsaW5lLjIyLCBkaXNjaXBsaW5lKQ0KICAgICAgICAgICAgfCBzdHJfZGV0ZWN0KGRlbW9ncmFwaGljcyRkaXNjaXBsaW5lLjI0LCBkaXNjaXBsaW5lKQ0KICAgICAgICAgICAgfCBzdHJfZGV0ZWN0KGRlbW9ncmFwaGljcyRkaXNjaXBsaW5lLjI1LCBkaXNjaXBsaW5lKQ0KICAgICAgICApIHw+IHJlcGxhY2VfbmEoRkFMU0UpKQ0KDQogICAgZGVtb2dyYXBoaWNzX3NvYyA9IGRlbW9ncmFwaGljc1tzYW1wbGUsIF0gfD4gZHJvcF9uYShpZCkNCg0KICAgICMgc3RlcCAyDQogICAgaWRzID0gZGVtb2dyYXBoaWNzX3NvYyRpZCB8PiB1bmlxdWUoKQ0KDQoNCiAgICBzY2hvbGFyc19zZWwgPSBsaXN0KCkgDQogICAgZm9yIChpZF8gaW4gaWRzKXsNCiAgICAgICAgc2Nob2xhcnNfc2VsW1tpZF9dXSA9IGJpbmRfcm93cyhzY2hvbGFycyR3b3JrcykgfD4NCiAgICAgICAgICAgIGZpbHRlcihhdXRob3JfaWQgPT0gaWRfKQ0KICAgIH0NCiAgICBzY2hvbGFyc19zZWwgPSBiaW5kX3Jvd3Moc2Nob2xhcnMkd29ya3MpIA0KICAgIA0KDQogICAgbndhdmVzID0gbGVuZ3RoKHdhdmVzKQ0KICAgIG5ldHMgPSBhcnJheSgwLCBkaW0gPSBjKG53YXZlcywgbGVuZ3RoKGlkcyksIGxlbmd0aChpZHMpKSwgZGltbmFtZXMgPSBsaXN0KHdhdmUgPSAxOm53YXZlcywgaWRzLA0KICAgICAgICBpZHMpKQ0KICAgIGRpbW5hbWVzKG5ldHMpDQoNCiAgICAjIHN0ZXAgMw0KICAgIGRmX3dvcmtzID0gdGliYmxlKA0KICAgICAgICAgICAgd29ya3NfaWQgPSBzY2hvbGFyc19zZWwkaWQsIA0KICAgICAgICAgICAgd29ya3NfYXV0aG9yID0gc2Nob2xhcnNfc2VsJGF1dGhvcnNoaXBzLCANCiAgICAgICAgICAgIHdvcmtzX3llYXIgPSBzY2hvbGFyc19zZWwkcHVibGljYXRpb25feWVhcg0KICAgICAgICApDQoNCg0KICAgIGRmX3dvcmtzID0gZGZfd29ya3NbIWR1cGxpY2F0ZWQoZGZfd29ya3MpLCBdDQoNCiAgICAjIHN0ZXAgNA0KICAgIGlmICh0eXBlID09ICJmaXJzdCIpIHsNCiAgICAgICAgZm9yIChqIGluIDE6bGVuZ3RoKHdhdmVzKSkgew0KICAgICAgICAgICAgZGZfd29ya3NfdyA9IGRmX3dvcmtzW2RmX3dvcmtzJHdvcmtzX3llYXIgPj0gd2F2ZXNbW2pdXVsxXSAmIGRmX3dvcmtzJHdvcmtzX3llYXIgPD0gd2F2ZXNbW2pdXVsyXSwNCiAgICAgICAgICAgICAgICBdDQogICAgICAgICAgICBmb3IgKGkgaW4gMTpucm93KGRmX3dvcmtzX3cpKSB7DQogICAgICAgICAgICAgICAgZWdvID0gZGZfd29ya3NfdyR3b3Jrc19hdXRob3JbaV1bWzFdXSRpZFsxXQ0KICAgICAgICAgICAgICAgIGFsdGVycyA9IGRmX3dvcmtzX3ckd29ya3NfYXV0aG9yW2ldW1sxXV0kaWRbLTFdDQogICAgICAgICAgICAgICAgaWYgKHN1bShpZHMgJWluJSBlZ28pID4gMCAmIHN1bShpZHMgJWluJSBhbHRlcnMpID4gMCkgew0KICAgICAgICAgICAgICAgICAgbmV0c1tqLCB3aGljaChpZHMgJWluJSBlZ28pLCB3aGljaChpZHMgJWluJSBhbHRlcnMpXSA9IDENCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICB9DQoNCiAgICBpZiAodHlwZSA9PSAibGFzdCIpIHsNCiAgICAgICAgZm9yIChqIGluIDE6bGVuZ3RoKHdhdmVzKSkgew0KICAgICAgICAgICAgZGZfd29ya3NfdyA9IGRmX3dvcmtzW2RmX3dvcmtzJHdvcmtzX3llYXIgPj0gd2F2ZXNbW2pdXVsxXSAmIGRmX3dvcmtzJHdvcmtzX3llYXIgPD0gd2F2ZXNbW2pdXVsyXSwNCiAgICAgICAgICAgICAgICBdDQogICAgICAgICAgICBmb3IgKGkgaW4gMTpucm93KGRmX3dvcmtzX3cpKSB7DQogICAgICAgICAgICAgICAgZWdvID0gcmV2KGRmX3dvcmtzX3ckd29ya3NfYXV0aG9yW2ldW1sxXV0kaWRbMV0pDQogICAgICAgICAgICAgICAgYWx0ZXJzID0gcmV2KGRmX3dvcmtzX3ckd29ya3NfYXV0aG9yW2ldW1sxXV0kaWRbLTFdKQ0KICAgICAgICAgICAgICAgIGlmIChzdW0oaWRzICVpbiUgZWdvKSA+IDAgJiBzdW0oaWRzICVpbiUgYWx0ZXJzKSA+IDApIHsNCiAgICAgICAgICAgICAgICAgIG5ldHNbaiwgd2hpY2goaWRzICVpbiUgZWdvKSwgd2hpY2goaWRzICVpbiUgYWx0ZXJzKV0gPSAxDQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgfQ0KICAgIGlmICh0eXBlID09ICJhbGwiKSB7DQogICAgICAgIGZvciAoaiBpbiAxOmxlbmd0aCh3YXZlcykpIHsNCiAgICAgICAgICAgIGRmX3dvcmtzX3cgPSBkZl93b3Jrc1tkZl93b3JrcyR3b3Jrc195ZWFyID49IHdhdmVzW1tqXV1bMV0gJiBkZl93b3JrcyR3b3Jrc195ZWFyIDw9IHdhdmVzW1tqXV1bMl0sDQogICAgICAgICAgICAgICAgXQ0KICAgICAgICAgICAgZm9yIChpIGluIDE6bnJvdyhkZl93b3Jrc193KSkgew0KICAgICAgICAgICAgICAgIGVnb3MgPSBkZl93b3Jrc193JHdvcmtzX2F1dGhvcltpXVtbMV1dJGlkDQogICAgICAgICAgICAgICAgaWYgKHN1bShpZHMgJWluJSBlZ29zKSA+IDApIHsNCiAgICAgICAgICAgICAgICAgIG5ldHNbaiwgd2hpY2goaWRzICVpbiUgZWdvcyksIHdoaWNoKGlkcyAlaW4lIGVnb3MpXSA9IDENCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICB9DQogICAgICAgICAgICBkaWFnKG5ldHNbaiwsXSkgPSAwDQogICAgICAgIH0NCiAgICB9DQoNCiAgICBvdXRwdXQgPSBsaXN0KCkNCiAgICBvdXRwdXQkZGF0YSA9IGRlbW9ncmFwaGljc19zb2MNCiAgICBvdXRwdXQkbmV0cyA9IG5ldHMNCiAgICByZXR1cm4ob3V0cHV0KQ0KfQ0KDQojU3RyaW5nIHVuaWZvcm1pbmcgZnVuY3Rpb24NCmZ1bmlmb3JtX3N0cmluZyA8LSBmdW5jdGlvbihpbnB1dCwgbnVtYmVycz1UUlVFLCBzcGFjZXM9VFJVRSwgY2Fwcz1UUlVFKXsNCiAgc3RyaW5nIDwtIGljb252KGlucHV0LCBmcm9tID0gIlVURi04IiwgdG8gPSAiQVNDSUkvL1RSQU5TTElUIikNCiAgc3RyaW5nIDwtIGdzdWIoJy0nLCcnLHN0cmluZykNCiAgaWYgKG51bWJlcnMpIHN0cmluZyA8LSBnc3ViKCdbMC05XScsJycsc3RyaW5nKQ0KICBpZiAoc3BhY2VzKSBzdHJpbmcgPC0gZ3N1YignICcsJycsc3RyaW5nKQ0KICBpZiAoY2Fwcykgc3RyaW5nIDwtIHRvbG93ZXIoc3RyaW5nKQ0KICByZXR1cm4oc3RyaW5nKQ0KfQ0KDQojQ2hlY2tpbmcgZm9yIHJlcXVpcmVkIHBhY2thZ2VzDQpwYWNrYWdlcyA9IGMoIlJTaWVuYSIsICJkZXZ0b29scyIsICJpZ3JhcGgiLCAidGlkeXZlcnNlIiwgInhtbDIiLCAicnZlc3QiLCAiZHBseXIiLCAic3RyaW5nciIpDQpmcGFja2FnZS5jaGVjayhwYWNrYWdlcykNCg0KYGBgDQoNCmBgYHtyLGV2YWw9Rn0NCiNGaXJzdCBzdGVwIGlzIHRvIHNjcmFwZSB0aGUgSUNTIHdlYnNpdGUgZm9yIGdyYWR1YXRlcyBhbmQgYWZmaWxpYXRlcw0KI1dlIHdhbnQgdG8gaGF2ZSBhIGxpc3Qgb2YgbmFtZXMgYW5kIHR3byBkdW1teSB2YXJpYWJsZXMsIG9uZSBmb3IgZ3JhZHVhdGlvbiBhbmQgb25lIGZvciBhZmZpbGlhdGlvbg0KI0JlaW5nIGFibGUgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGUgdHdvIHdpbGwgYWxsb3cgdXMgdG8gY2FwdHVyZSBvbGRlciBzb2Npb2xvZ2lzdHMgd2hvIGFyZSB3aXRoaW4NCiAgI3RoZSBzY29wZSBvZiB0aGUgdGhlb3J5LCBidXQgY291bGQgbm90IGhhdmUgc3R1ZGllZCBhdCBJQ1MgYmVjYXVzZSBpdCBkaWQgbm90IGV4aXN0IHlldA0KDQojRmlyc3Qgd2UgZ2V0IHRoZSBhZmZpbGlhdGVzIHRhYmxlcyBmcm9tIGh0dHBzOi8vaWNzLWdyYWR1YXRlc2Nob29sLm5sLw0KDQojRmFjdWx0eSANCmljc2ZhYzwtcmVhZF9odG1sKCJodHRwczovL2ljcy1ncmFkdWF0ZXNjaG9vbC5ubC9mYWN1bHR5LyIpIA0KaWNzZmFjPC1pY3NmYWMgJT4lIGh0bWxfbm9kZXMoImJvZHkiKSAlPiUgeG1sX2ZpbmRfYWxsKCIvL3Rib2R5IikgJT4lIGh0bWxfdGFibGUoKSANCmljc2ZhYzwtYmluZF9yb3dzKGljc2ZhYykgDQppY3NmYWMkWDU8LSJGYWN1bHR5Ig0KDQojUG9zdGRvY3MgDQppY3Nwb3N0PC1yZWFkX2h0bWwoImh0dHBzOi8vaWNzLWdyYWR1YXRlc2Nob29sLm5sL3Bvc3Rkb2NzLyIpIA0KaWNzcG9zdDwtaWNzcG9zdCAlPiUgaHRtbF9ub2RlcygiYm9keSIpICU+JSB4bWxfZmluZF9hbGwoIi8vdGJvZHkiKSAlPiUgaHRtbF90YWJsZSgpIA0KaWNzcG9zdDwtYmluZF9yb3dzKGljc3Bvc3QpIA0KaWNzcG9zdCRYNTwtIlBvc3Rkb2MiDQoNCiNQaERzIA0KaWNzcGhkPC1yZWFkX2h0bWwoImh0dHBzOi8vaWNzLWdyYWR1YXRlc2Nob29sLm5sL3BoZHMvIikgDQppY3NwaGQ8LWljc3BoZCAlPiUgaHRtbF9ub2RlcygiYm9keSIpICU+JSB4bWxfZmluZF9hbGwoIi8vdGJvZHkiKSAlPiUgaHRtbF90YWJsZSgpIA0KaWNzcGhkPC1iaW5kX3Jvd3MoaWNzcGhkKSANCmljc3BoZCRYNTwtIlBoRCINCg0KI01lcmdpbmcgaW50byBvbmUgdGFibGUgDQppY3NBPC1yYmluZChpY3NmYWMsaWNzcG9zdCkgDQppY3NBPC1yYmluZChpY3NBLGljc3BoZCkNCmljc0EkaWNzQWZmaWxpYXRlPC0xDQoNCiNNYWtpbmcgZmlyc3QgYW5kIGxhc3QgbmFtZXMgaW50byBJRCB2YXJpYWJsZSBmb3IgbWF0Y2hpbmcNCmljc0EkTmFhbTwtcGFzdGUoaWNzQSRYMSxpY3NBJFgyKQ0KaWNzQSROYWFtPC1mdW5pZm9ybV9zdHJpbmcoaWNzQSROYWFtKQ0KDQojVGhlbiB3ZSBnZXQgdGhlIGxpc3Qgb2YgZ3JhZHVhdGVzIGZyb20gdGhlIHNhbWUgd2Vic2l0ZQ0KaWNzRzwtcmVhZF9odG1sKCJodHRwczovL2ljcy1ncmFkdWF0ZXNjaG9vbC5ubC9hbHVtbmktcHJvamVjdHMvIikNCmljc0c8LWljc0cgJT4lDQogIGh0bWxfbm9kZXMoImJvZHkiKSAlPiUNCiAgeG1sX2ZpbmRfYWxsKCIvL3Rib2R5IikgJT4lDQogIGh0bWxfdGFibGUoKQ0KaWNzRzwtYmluZF9yb3dzKGljc0cpDQppY3NHJGljc0dyYWR1YXRlPC0xDQppY3NHJE5hYW08LWZ1bmlmb3JtX3N0cmluZyhpY3NHJFgyKQ0KDQojTWVyZ2luZyB0aGUgSUNTIGFmZmlsaWF0ZXMgYW5kIGdyYWR1YXRlcyB0YWJsZXMNCmljc0M8LW1lcmdlKGljc0EsIGljc0csIGFsbCA9IFRSVUUsIGJ5ID0gIk5hYW0iKQ0KaWNzQyR1bmFhbTwtaWNzQyROYWFtDQppY3NGPC1pY3NDW2MoJ3VuYWFtJywnaWNzQWZmaWxpYXRlJywnaWNzR3JhZHVhdGUnKV0NCmljc0YkaWNzQW55PC0xDQppY3NGW2lzLm5hKGljc0YpXTwtMA0KDQpgYGANCg0KYGBge3IsZXZhbD1GfQ0KI1NlY29uZCBzdGVwIGlzIHRvIGxvYWQgYW5kIHRyYW5zZm9ybSB0aGUgY29sbGFib3JhdGlvbiBuZXR3b3JrIGRhdGEgYW5kIG1lcmdlIGl0IHdpdGggdGhlIElDUyBkYXRhDQoNCiNMb2FkaW5nIHRoZSBkYXRhDQpzY2hvbGFyczwtZmxvYWQoJ0M6Ly9Vc2Vycy9ncm9vdC9Eb2N1bWVudHMvUkRpcmVjdG9yeS8yMDI1MTAxNnNjaG9sYXJzLnJkYScpDQoNCiNTZWxlY3RpbmcgZm9yIHNvY2lvbG9naXN0cyBhbmQgdHJhbnNmb3JtaW5nIHVzaW5nIHRoZSBuZXR3b3JrIGRhdGEgaGVscGVyIGZ1bmN0aW9uDQpzbmRhdGExID0gZmNvbG5ldChzY2hvbGFycywgdW5pdmVyc2l0eSA9IGMoJ1JVJywgJ1VVJywgJ1V2QScsICdSVUcnLCAnVlUnLCAnVXZUJywgJ0VVUicpKQ0KZGZfZWdvMSA9IGJpbmRfcm93cyhzbmRhdGExJGRhdGEpDQoNCiNBZGRpbmcgdW5pZm9ybWVkIGF1dGhvciBuYW1lcyB0byB0aGUgZWdvIGxldmVsIGRhdGENCmRmX2VnbzEkdW5hYW08LWZ1bmlmb3JtX3N0cmluZyhkZl9lZ28xJG5hYW0pDQoNCiNNZXJnaW5nIHRoZSBJQ1MgdmFyaWFibGVzIGludG8gdGhlIGVnbyBsZXZlbCBkYXRhDQpkZl9lZ28yPC1tZXJnZSh4PWRmX2VnbzEseT1pY3NGLGFsbC54PVRSVUUpDQoNCiNSZXBsYWNpbmcgbWlzc2luZ3Mgb24gdGhlIElDUyB2YXJpYWJsZXMgd2l0aCAwIHRvIGNvbXBsZXRlIHRoZSBkdW1taWVzDQpkZl9lZ28yJGljc0FmZmlsaWF0ZVtpcy5uYShkZl9lZ28yJGljc0FmZmlsaWF0ZSldPC0wDQpkZl9lZ28yJGljc0dyYWR1YXRlW2lzLm5hKGRmX2VnbzIkaWNzR3JhZHVhdGUpXTwtMA0KZGZfZWdvMiRpY3NBbnlbaXMubmEoZGZfZWdvMiRpY3NBbnkpXTwtMA0KDQpgYGANCg0KYGBge3IsZXZhbD1GfQ0KI1RoZSB0aGlyZCBzdGVwIGlzIHRvIG1ha2UgdGhlIG5ldHdvcmsgZGF0YSByZWFkeSBmb3IgYW5hbHlzaXMgd2l0aCBSU2llbmENCg0KI01ha2luZyB3YXZlcw0Kd2F2ZTEgPSBzbmRhdGExJG5ldHNbMSwsXQ0Kd2F2ZTIgPSBzbmRhdGExJG5ldHNbMiwsXQ0Kd2F2ZTMgPSBzbmRhdGExJG5ldHNbMywsXQ0KDQojTWFraW5nIHRoZSB3YXZlcyBiYWNrIGludG8gYSBzaW5nbGUgZmlsZQ0KbmV0cyA9IGFycmF5KA0KICAgIGRhdGEgPSBjKHdhdmUxLCB3YXZlMiwgd2F2ZTMpLA0KICAgIGRpbSA9IGMoZGltKHdhdmUyKSwgMikpDQoNCiNNYWtpbmcgdGhlIFJTaWVuYSBub21pbmF0aW9uIG1hdHJpeA0KbmV0ID0gc2llbmFEZXBlbmRlbnQobmV0cykNCg0KYGBgDQoNCmBgYHtyLGV2YWw9Rn0NCiNCZWZvcmUgdHJhbnNmb3JtaW5nIHRoZSBlZ28gbGV2ZWwgdmFyaWFibGVzIGludG8gdGhlaXIgUlNpZW5hIHJlYWR5IGZvcm0sIA0KI3NvbWUgZGVzY3JpcHRpdmUgc3RhdGlzdGljcyBhcmUgcmVxdWlyZWQgdG8gZW5zdXJlIHRoYXQgc3RyYW5nZSBhbmQgbWlzc2luZyB2YWx1ZXMgYXJlIG5vdCBjYXJyaWVkIG92ZXINCg0KI1ZBUklBQkVMRU4gRElFIElLIFdJTDogZnVuY3RpZShvcmRpbmFhbCBtYWtlbiksIHVuaXZlcnNpdGVpdCwgZ2VuZGVyLCBpY3MgZGluZ2VuLCANCg0KI0ZpcnN0IG9mLCB0aGUgJ3VuaXZlcnNpdGVpdCcgdmFyaWFibGVzIGZvciBlYWNoIHllYXINCiNUaGVzZSB2YXJpYWJsZXMgaW5kaWNhdGUgZm9yIGVhY2ggc29jaW9sb2dpc3QgaW4gdGhlIGRhdGEgYXQgd2hpY2ggdW5pdmVyc2l0eSB0aGV5IHdvcmtlZCBpbiBlYWNoIHllYXINCg0KI0luc3BlY3RpbmcgdGhlIHZhcmlhYmxlcyB3aXRoIGZyZXF1ZW5jeSB0YWJsZXMNCnRhYmxlKGRmX2VnbzIkdW5pdmVyc2l0ZWl0LjIyLHVzZU5BPSdhbHdheXMnKQ0KdGFibGUoZGZfZWdvMiR1bml2ZXJzaXRlaXQuMjQsdXNlTkE9J2Fsd2F5cycpDQp0YWJsZShkZl9lZ28yJHVuaXZlcnNpdGVpdC4yNSx1c2VOQT0nYWx3YXlzJykNCg0KI1RoZSBmcmVxdWVuY3kgdGFibGVzIHNob3cgdGhhdCB0aGVyZSBhcmUgc2V2ZXJhbCBzb2Npb2xvZ2lzdCB3aG8gd29yayBhdCB0d28gdW5pdmVyc2l0aWVzDQojU29tZSBvZiB0aGVzZSB3b3JrIGF0IGEgRHV0Y2ggdW5pdmVyc2l0eSBhbmQgYSBmb3JlaWduIG9uZSwgDQojdGhvc2UgY2FzZXMgYXJlIG5vdyByZWNvZGVkIHRvIGluY2x1ZGUgb25seSB0aGUgRHV0Y2ggdW5pdmVyc2l0eQ0KZGZfZWdvMzwtZGZfZWdvMg0KZGZfZWdvMyR1bml2ZXJzaXRlaXQuMjI8LWdzdWIoJ0VVUi9Cb3N0b24gVW5pdmVyc2l0eScsICdFVVInLCBkZl9lZ28zJHVuaXZlcnNpdGVpdC4yMikNCmRmX2VnbzMkdW5pdmVyc2l0ZWl0LjI0PC1nc3ViKCdFVVIvQm9zdG9uIFVuaXZlcnNpdHknLCAnRVVSJywgZGZfZWdvMyR1bml2ZXJzaXRlaXQuMjQpDQpkZl9lZ28zJHVuaXZlcnNpdGVpdC4yMjwtZ3N1YignUlVHL1RVIERlbGZ0JywgJ1JVRycsIGRmX2VnbzMkdW5pdmVyc2l0ZWl0LjIyKQ0KZGZfZWdvMyR1bml2ZXJzaXRlaXQuMjQ8LWdzdWIoJ1JVRy9UVSBEZWxmdCcsICdSVUcnLCBkZl9lZ28zJHVuaXZlcnNpdGVpdC4yNCkNCmRmX2VnbzMkdW5pdmVyc2l0ZWl0LjIyPC1nc3ViKCdSVUcvVW5pdmVyc2l0ZWl0IFN0b2NraG9sbScsICdSVUcnLCBkZl9lZ28zJHVuaXZlcnNpdGVpdC4yMikNCmRmX2VnbzMkdW5pdmVyc2l0ZWl0LjI0PC1nc3ViKCdSVUcvVW5pdmVyc2l0ZWl0IFN0b2NraG9sbScsICdSVUcnLCBkZl9lZ28zJHVuaXZlcnNpdGVpdC4yNCkNCmRmX2VnbzMkdW5pdmVyc2l0ZWl0LjIyPC1nc3ViKCdSVUcvVW5pdmVyc2l0eSBMaW5rw7ZwaW5nJywgJ1JVRycsIGRmX2VnbzMkdW5pdmVyc2l0ZWl0LjIyKQ0KZGZfZWdvMyR1bml2ZXJzaXRlaXQuMjQ8LWdzdWIoJ1JVRy9Vbml2ZXJzaXR5IExpbmvDtnBpbmcnLCAnUlVHJywgZGZfZWdvMyR1bml2ZXJzaXRlaXQuMjQpDQpkZl9lZ28zJHVuaXZlcnNpdGVpdC4yMjwtZ3N1YignUlVHL1VuaXZlcnNpdHkgb2YgVHVya3UnLCAnUlVHJywgZGZfZWdvMyR1bml2ZXJzaXRlaXQuMjIpDQpkZl9lZ28zJHVuaXZlcnNpdGVpdC4yNDwtZ3N1YignUlVHL1VuaXZlcnNpdHkgb2YgVHVya3UnLCAnUlVHJywgZGZfZWdvMyR1bml2ZXJzaXRlaXQuMjQpDQpkZl9lZ28zJHVuaXZlcnNpdGVpdC4yMjwtZ3N1YignVXZBL0ZyYW5rZnVydCBTY2hvb2wgb2YgRmluYW5jZSAmIE1hbmFnZW1lbnQnLCAnVXZBJywgZGZfZWdvMyR1bml2ZXJzaXRlaXQuMjIpDQpkZl9lZ28zJHVuaXZlcnNpdGVpdC4yNDwtZ3N1YignVXZBL0ZyYW5rZnVydCBTY2hvb2wgb2YgRmluYW5jZSAmIE1hbmFnZW1lbnQnLCAnVXZBJywgZGZfZWdvMyR1bml2ZXJzaXRlaXQuMjQpDQpkZl9lZ28zJHVuaXZlcnNpdGVpdC4yMjwtZ3N1YignVXZBL1VuaXZlcnNpdHkgb2YgTGF1c2FubmUnLCAnVXZBJywgZGZfZWdvMyR1bml2ZXJzaXRlaXQuMjIpDQpkZl9lZ28zJHVuaXZlcnNpdGVpdC4yNDwtZ3N1YignVXZBL1VuaXZlcnNpdHkgb2YgTGF1c2FubmUnLCAnVXZBJywgZGZfZWdvMyR1bml2ZXJzaXRlaXQuMjQpDQpkZl9lZ28zJHVuaXZlcnNpdGVpdC4yMjwtZ3N1YignVXZUL1RyZW50byBVbml2ZXJzaXR5JywgJ1V2VCcsIGRmX2VnbzMkdW5pdmVyc2l0ZWl0LjIyKQ0KZGZfZWdvMyR1bml2ZXJzaXRlaXQuMjQ8LWdzdWIoJ1V2VC9UcmVudG8gVW5pdmVyc2l0eScsICdVdlQnLCBkZl9lZ28zJHVuaXZlcnNpdGVpdC4yNCkNCmRmX2VnbzMkdW5pdmVyc2l0ZWl0LjIyPC1nc3ViKCdWVS9VdkgnLCAnVlUnLCBkZl9lZ28zJHVuaXZlcnNpdGVpdC4yMikNCmRmX2VnbzMkdW5pdmVyc2l0ZWl0LjI0PC1nc3ViKCdWVS9VdkgnLCAnVlUnLCBkZl9lZ28zJHVuaXZlcnNpdGVpdC4yNCkNCmRmX2VnbzMkdW5pdmVyc2l0ZWl0LjI0PC1nc3ViKCdSVUcvVW5pdmVyc2l0eSBvZiBMZWlwemlnJywgJ1JVRycsIGRmX2VnbzMkdW5pdmVyc2l0ZWl0LjI0KQ0KDQojQW5kIG1ha2Ugb25seSBmb3JlaWduIHVuaXZlcnNpdHkgaW50byBOQSBhbmQgcmVtb3ZlIHF1ZXN0aW9uIG1hcmtzDQpkZl9lZ28zJHVuaXZlcnNpdGVpdC4yNDwtZ3N1YignVW5pdmVyc2l0eSBvZiBDb2xvZ25lJywgTkEsIGRmX2VnbzMkdW5pdmVyc2l0ZWl0LjI0KQ0KZGZfZWdvMyR1bml2ZXJzaXRlaXQuMjQ8LWdzdWIoJ1s/XScsICcnLCBkZl9lZ28zJHVuaXZlcnNpdGVpdC4yNCkNCg0KI0NoZWNraW5nIHRoZSBmcmVxdWVuY2llcyBhZ2Fpbg0KdGFibGUoZGZfZWdvMyR1bml2ZXJzaXRlaXQuMjIsdXNlTkE9J2Fsd2F5cycpDQp0YWJsZShkZl9lZ28zJHVuaXZlcnNpdGVpdC4yNCx1c2VOQT0nYWx3YXlzJykNCnRhYmxlKGRmX2VnbzMkdW5pdmVyc2l0ZWl0LjI1LHVzZU5BPSdhbHdheXMnKQ0KDQojTm93IG1vc3Qgb2YgdGhlIGNhc2VzIGFyZSBmaW5lLCBleGNlcHQgZm9yIHRoZSBmZXcgdGhhdCBoYXZlIHR3byB1bml2ZXJzaXRpZXMNCiNGb3IgdGhlc2UgY2FzZXMgdGhlIGZpcnN0IG9mIHRoZSB0d28gcmVwb3J0ZWQgdW5pdmVyc2l0aWVzIGlzIHRha2VuIGFzIHByaW1hcnksDQojYW5kIGlzIHRodXMgc2VsZWN0ZWQgYXMgdGhlIHZhbHVlIG9mIHRoZSB1bml2ZXJzaXR5IHZhcmlhYmxlDQojTG9zcyBvZiBpbmZvcm1hdGlvbiB3YXMgYWNjZXB0ZWQgaW4gdGhpcyBjYXNlIGJlY2F1c2UgYWRkaW5nIGEgJ3NlY29uZCB1bml2ZXJzaXR5JyB2YXJpYWJsZSBmb3IgNSBzb2Npb2xvZ2lzdHMNCiN3b3VsZCBtZWFuIGNoYW5naW5nIHRoZSBhbmFseXNpcyBxdWl0ZSBzdWJzdGFudGlhbGx5IGZvciB3aGF0IGlzIGxpa2VseSB0byBiZSBubyBzaWduaWZpY2FudCBkaWZmZXJlbmNlDQpkZl9lZ28zJHVuaXZlcnNpdGVpdC4yMjwtZ3N1YignUlUvUlVHJywgJ1JVJywgZGZfZWdvMyR1bml2ZXJzaXRlaXQuMjIpDQpkZl9lZ28zJHVuaXZlcnNpdGVpdC4yNDwtZ3N1YignUlUvUlVHJywgJ1JVJywgZGZfZWdvMyR1bml2ZXJzaXRlaXQuMjQpDQpkZl9lZ28zJHVuaXZlcnNpdGVpdC4yMjwtZ3N1YignUlVHL1JVJywgJ1JVRycsIGRmX2VnbzMkdW5pdmVyc2l0ZWl0LjIyKQ0KZGZfZWdvMyR1bml2ZXJzaXRlaXQuMjQ8LWdzdWIoJ1JVRy9SVScsICdSVUcnLCBkZl9lZ28zJHVuaXZlcnNpdGVpdC4yNCkNCmRmX2VnbzMkdW5pdmVyc2l0ZWl0LjIyPC1nc3ViKCdSVUcvVGlsYnVyZycsICdSVUcnLCBkZl9lZ28zJHVuaXZlcnNpdGVpdC4yMikNCmRmX2VnbzMkdW5pdmVyc2l0ZWl0LjI0PC1nc3ViKCdSVUcvVGlsYnVyZycsICdSVUcnLCBkZl9lZ28zJHVuaXZlcnNpdGVpdC4yNCkNCmRmX2VnbzMkdW5pdmVyc2l0ZWl0LjIyPC1nc3ViKCdVdkEvRVVSJywgJ1V2QScsIGRmX2VnbzMkdW5pdmVyc2l0ZWl0LjIyKQ0KZGZfZWdvMyR1bml2ZXJzaXRlaXQuMjI8LWdzdWIoJ1VVL1V2QScsICdVVScsIGRmX2VnbzMkdW5pdmVyc2l0ZWl0LjIyKQ0KZGZfZWdvMyR1bml2ZXJzaXRlaXQuMjQ8LWdzdWIoJ1VVL1V2QScsICdVVScsIGRmX2VnbzMkdW5pdmVyc2l0ZWl0LjI0KQ0KDQojQ2hlY2tpbmcgZnJlcXVlbmNpZXMgYWdhaW4NCnRhYmxlKGRmX2VnbzMkdW5pdmVyc2l0ZWl0LjIyLHVzZU5BPSdhbHdheXMnKQ0KdGFibGUoZGZfZWdvMyR1bml2ZXJzaXRlaXQuMjQsdXNlTkE9J2Fsd2F5cycpDQp0YWJsZShkZl9lZ28zJHVuaXZlcnNpdGVpdC4yNSx1c2VOQT0nYWx3YXlzJykNCg0KI1RoZXJlIGFyZSBubyBtb3JlIHN0cmFuZ2UgdmFsdWVzIGZvciB0aGUgJ3VuaXZlcnNpdGVpdCcgdmFyaWFibGVzDQojTm93IG9uIHRvIHRoZSAnZnVuY3RpZScgdmFyaWFibGVzLCB0aGVzZSBzaG93IHRoZSBzb2Npb2xvZ2lzdHMnIGpvYiB0aXRsZXMNCnRhYmxlKGRmX2VnbzMkZnVuY3RpZS4yMix1c2VOQT0nYWx3YXlzJykNCnRhYmxlKGRmX2VnbzMkZnVuY3RpZS4yNCx1c2VOQT0nYWx3YXlzJykNCnRhYmxlKGRmX2VnbzMkZnVuY3RpZS4yNSx1c2VOQT0nYWx3YXlzJykNCg0KI1RoZXJlIGlzIG9uZSBzbGlnaHRseSBub25kZXNjcmlwdCB2YWx1ZSBoZXJlLCBuYW1lbHkgJ3N0YWZmJw0KI0ZvciB0aGUgZmV3IHBlb3BsZSB3aXRoIHRoaXMgdmFsdWUsIA0KI0kgZGVjaWRlZCB0byBmaXJzdCBzZWUgaWYgYSBtb3JlIGluZm9ybWF0aXZlIHRpdGxlIGlzIGdpdmVuIGluIGFub3RoZXIgeWVhciwgDQojdGhlbiBjaGVjayB1bml2ZXJzaXR5IHdlYnNpdGVzIGFuZCBzb2NpYWwgbWVkaWENCiNOaW5lIHNvY2lvbG9naXN0IHdlcmUgZ2l2ZW4gbW9yZSBpbmZvcm1hdGl2ZSB2YWx1ZXMgZm9yIHRoZSBmdW5jdGlvbiB2YXJpYWJsZSB0aGlzIHdheQ0KZGZfZWdvMyRmdW5jc3ViPC1kZl9lZ28zJGZ1bmN0aWUuMjINCmRmX2VnbzNbODYsJ2Z1bmNzdWInXTwtJ1BoRCBDYW5kaWRhdGUnDQpkZl9lZ28zWzg5LCdmdW5jc3ViJ108LSdSZXNlYXJjaGVyJw0KZGZfZWdvM1sxNDMsJ2Z1bmNzdWInXTwtJ0Fzc2lzdGFudCBQcm9mZXNzb3InDQpkZl9lZ28zWzE5MCwnZnVuY3N1YiddPC0nTGVjdHVyZXInDQpkZl9lZ28zWzI4NCwnZnVuY3N1YiddPC0nTGVjdHVyZXInDQpkZl9lZ28zWzM4NSwnZnVuY3N1YiddPC0nUmVzZWFyY2hlcicNCmRmX2VnbzNbNDE4LCdmdW5jc3ViJ108LSdGdWxsIFByb2Zlc3NvcicNCmRmX2VnbzNbNDE5LCdmdW5jc3ViJ108LSdSZXNlYXJjaGVyJw0KZGZfZWdvM1s0MzEsJ2Z1bmNzdWInXTwtJ0xlY3R1cmVyJw0KDQojQ2hlY2sgZGlzdHJpYnV0aW9uDQp0YWJsZShkZl9lZ28zJGZ1bmNzdWIsdXNlTkE9J2Fsd2F5cycpDQoNCiNMYXN0bHkgdGhlcmUgaXMgdGhlIGdlbmRlciB2YXJpYWJsZSwgd2hpY2ggaGFzIGZpdmUgbWlzc2luZ3MNCnRhYmxlKGRmX2VnbzMkZ2VuZGVyLHVzZU5BPSdhbHdheXMnKQ0KDQojVGhlc2UgbWlzc2luZ3Mgd2VyZSBpbXB1dGVkIGJ5IGdvb2dsaW5nIHRoZWlyIG5hbWUgYW5kIHRoZSB1bml2ZXJzaXR5IHRoZXkgd29yayBhdA0KI0EgcGljdHVyZSB3YXMgZm91bmQgZm9yIGFsbCBmaXZlLCBnZW5kZXIgd2FzIGluZmVycmVkIGJhc2VkIG9uIGdlbmRlciBzaWduaWZpZXJzIHNlZW4gaW4gdGhlIHBpY3R1cmVzDQojTWFpbiBzaWduaWZpZXJzIHVzZWQgd2VyZSBsZW5ndGggb2YgaGFpciBhbmQgcHJlc2VuY2Ugb2YgcHJvbWluZW50IGZhY2lhbCBoYWlyDQpkZl9lZ28zWzEyMywnZ2VuZGVyJ108LSdmZW1hbGUnDQpkZl9lZ28zWzIzNywnZ2VuZGVyJ108LSdtYWxlJw0KZGZfZWdvM1szNzUsJ2dlbmRlciddPC0nZmVtYWxlJw0KZGZfZWdvM1s0MTIsJ2dlbmRlciddPC0nbWFsZScNCmRmX2VnbzNbNDYyLCdnZW5kZXInXTwtJ2ZlbWFsZScNCg0KI0NoZWNraW5nIHRvIG1ha2Ugc3VyZSB0aGVyZSBhcmUgbm8gbW9yZSBtaXNzaW5ncyBmb3IgZ2VuZGVyDQp0YWJsZShkZl9lZ28zJGdlbmRlcix1c2VOQT0nYWx3YXlzJykNCg0KI0FuZCBub3cgdGhlIHZhcmlhYmxlcyBhcmUgcmVhZHkgZm9yIHRyYW5zZm9ybWF0aW9uIGludG8gdGhlIGZvcm0gdGhhdCB3aWxsIGJlIHVzZWQgaW4gYW5hbHlzaXMNCmBgYA0KDQpgYGB7cixldmFsPUZ9DQojTm93IHRvIHRyYW5zZm9ybSB0aGUgdGhyZWUgZWdvIGxldmVsIHZhcmlhYmxlcyBmcm9tIHRoZSBvcmlnaW5hbCBkYXRhDQoNCiNTdGFydGluZyB3aXRoICd1bml2ZXJzaXR5Jw0KI0kgd2FudCB0aGVyZSB0byBiZSBvbmUgdmFyaWFibGUgaW5kaWNhdGluZyB0aGUgdW5pdmVyc2l0eSBlYWNoIHNvY2lvbG9naXN0IGlzIG1vc3QgYWZmaWxpYXRlZCB3aXRoDQojQnkgbW9zdCBhZmZpbGlhdGVkIEkgbWFpbmx5IG1lYW4gaG93IGxvbmcgdGhleSB3ZXJlIGFmZmlsaWF0ZWQgd2l0aCBhIHVuaXZlcnNpdHksIHNvIHdoZXJlIHRoZXkgd291bGQgaGF2ZQ0KI3NwZW50IHRoZSBtb3N0IHRpbWUgYW5kIHByZXN1bWFibHksIGFzIGlzIG1vc3QgcmVsZXZhbnQsIGNvbGxhYm9yYXRlZCBtb3N0DQojQXMgc3VjaCwgdGhlIGJhc2lzIGZvciB0aGUgJ3VuaXZlcnNpdHknIHZhcmlhYmxlIHdpbGwgYmUgdGhlICd1bml2ZXJzaXRlaXQuMjInIHZhcmlhYmxlLCB3aXRoIGFueSBtaXNzaW5nDQojdmFsdWVzIG9uIHRoaXMgdmFyaWFibGUgYmVpbmcgc3VwcGxlbWVudGVkIGZpcnN0IHdpdGggJ3VuaXZlcnNpdGVpdC4yNCcgYW5kIHRoZW4gJ3VuaXZlcnNpdGVpdC4yNScgaWYgbmVlZGVkDQoNCiNJbiBvcmRlciB0byBkbyB0aGlzLCB0aGUgdW5pdmVyc2l0aWVzIHdpdGggdGhyZWUgbGV0dGVyIGFiYnJldmlhdGlvbnMgYXJlIGFiYnJldmlhdGVkIHRvIHR3byBsZXR0ZXJzDQojMjAyMg0KZGZfZWdvMyR1bmkyMjwtZGZfZWdvMyR1bml2ZXJzaXRlaXQuMjINCmRmX2VnbzMkdW5pMjI8LWdzdWIoJ0VVUicsJ0VVJyxkZl9lZ28zJHVuaTIyKQ0KZGZfZWdvMyR1bmkyMjwtZ3N1YignUlVHJywnVUcnLGRmX2VnbzMkdW5pMjIpDQpkZl9lZ28zJHVuaTIyPC1nc3ViKCdVdkEnLCdVQScsZGZfZWdvMyR1bmkyMikNCmRmX2VnbzMkdW5pMjI8LWdzdWIoJ1V2VCcsJ1VUJyxkZl9lZ28zJHVuaTIyKQ0KDQojMjAyNA0KZGZfZWdvMyR1bmkyNDwtZGZfZWdvMyR1bml2ZXJzaXRlaXQuMjQNCmRmX2VnbzMkdW5pMjQ8LWdzdWIoJ0VVUicsJ0VVJyxkZl9lZ28zJHVuaTI0KQ0KZGZfZWdvMyR1bmkyNDwtZ3N1YignUlVHJywnVUcnLGRmX2VnbzMkdW5pMjQpDQpkZl9lZ28zJHVuaTI0PC1nc3ViKCdVdkEnLCdVQScsZGZfZWdvMyR1bmkyNCkNCmRmX2VnbzMkdW5pMjQ8LWdzdWIoJ1V2VCcsJ1VUJyxkZl9lZ28zJHVuaTI0KQ0KDQojMjAyNQ0KZGZfZWdvMyR1bmkyNTwtZGZfZWdvMyR1bml2ZXJzaXRlaXQuMjUNCmRmX2VnbzMkdW5pMjU8LWdzdWIoJ0VVUicsJ0VVJyxkZl9lZ28zJHVuaTI1KQ0KZGZfZWdvMyR1bmkyNTwtZ3N1YignUlVHJywnVUcnLGRmX2VnbzMkdW5pMjUpDQpkZl9lZ28zJHVuaTI1PC1nc3ViKCdVdkEnLCdVQScsZGZfZWdvMyR1bmkyNSkNCmRmX2VnbzMkdW5pMjU8LWdzdWIoJ1V2VCcsJ1VUJyxkZl9lZ28zJHVuaTI1KQ0KDQojQ2hlY2sgaWYgdGhpcyB3b3JrZWQNCnRhYmxlKGRmX2VnbzMkdW5pMjIsZGZfZWdvMyR1bml2ZXJzaXRlaXQuMjIsdXNlTkE9J2Fsd2F5cycpDQp0YWJsZShkZl9lZ28zJHVuaTI0LGRmX2VnbzMkdW5pdmVyc2l0ZWl0LjI0LHVzZU5BPSdhbHdheXMnKQ0KdGFibGUoZGZfZWdvMyR1bmkyNSxkZl9lZ28zJHVuaXZlcnNpdGVpdC4yNSx1c2VOQT0nYWx3YXlzJykNCg0KI1RoaXMgd29ya2VkLCBhbGwgdW5pdmVyc2l0aWVzIG5vdyB1c2UgdHdvIGxldHRlciBhYmJyZXZpYXRpb25zDQojTm93IHRvIG1ha2Ugb25lIHZhcmlhYmxlIHdoaWNoIGluY2x1ZGVzIG9ubHkgdGhlIGVhcmxpZXN0IHVuaXZlcnNpdHkgYXZhaWxhYmxlIGZvciBlYWNoIHNvY2lvbG9naXN0DQpkZl9lZ28zJHVuaXZlcnNpdHk8LXBhc3RlKGRmX2VnbzMkdW5pMjIsZGZfZWdvMyR1bmkyNCxkZl9lZ28zJHVuaTI1KQ0KZGZfZWdvMyR1bml2ZXJzaXR5PC1nc3ViKCdOQScsJycsZGZfZWdvMyR1bml2ZXJzaXR5KQ0KZGZfZWdvMyR1bml2ZXJzaXR5PC1nc3ViKCcgJywnJyxkZl9lZ28zJHVuaXZlcnNpdHkpDQpkZl9lZ28zJHVuaXZlcnNpdHk8LXN1YnN0cihkZl9lZ28zJHVuaXZlcnNpdHksc3RhcnQ9MSxzdG9wPTIpDQoNCiNDaGVjayBpZiB0aGlzIHdvcmtlZCBieSBpbnNwZWN0aW5nIGEgbGlzdA0KdW5pdmVyc2l0eUNoZWNrPC1jYmluZC5kYXRhLmZyYW1lKGRmX2VnbzMkdW5pMjIsZGZfZWdvMyR1bmkyNCxkZl9lZ28zJHVuaTI1LGRmX2VnbzMkdW5pdmVyc2l0eSkNCnZpZXcodW5pdmVyc2l0eUNoZWNrKQ0Kcm0odW5pdmVyc2l0eUNoZWNrKQ0KDQojRGlzdHJpYnV0aW9uIG9mIHRoZSBuZXcgJ3VuaXZlcnNpdHknIHZhcmlhYmxlDQp0YWJsZShkZl9lZ28zJHVuaXZlcnNpdHksdXNlTkE9J2Fsd2F5cycpDQoNCiNOb3cgYXMgYSBmaW5hbCB0cmFuc2Zvcm1hdGlvbiwgdGhlIHZhcmlhYmxlIHdpbGwgYmUgbWFkZSBudW1lcmljIGZvciB1c2UgaW4gUlNpZW5hDQpkZl9lZ28zJHVuaXZlcnNpdHlOPC1kZl9lZ28zJHVuaXZlcnNpdHkNCmRmX2VnbzMkdW5pdmVyc2l0eU48LWdzdWIoJ0VVJywwLGRmX2VnbzMkdW5pdmVyc2l0eU4pDQpkZl9lZ28zJHVuaXZlcnNpdHlOPC1nc3ViKCdSVScsMSxkZl9lZ28zJHVuaXZlcnNpdHlOKQ0KZGZfZWdvMyR1bml2ZXJzaXR5TjwtZ3N1YignVUEnLDIsZGZfZWdvMyR1bml2ZXJzaXR5TikNCmRmX2VnbzMkdW5pdmVyc2l0eU48LWdzdWIoJ1VHJywzLGRmX2VnbzMkdW5pdmVyc2l0eU4pDQpkZl9lZ28zJHVuaXZlcnNpdHlOPC1nc3ViKCdVVCcsNCxkZl9lZ28zJHVuaXZlcnNpdHlOKQ0KZGZfZWdvMyR1bml2ZXJzaXR5TjwtZ3N1YignVVUnLDUsZGZfZWdvMyR1bml2ZXJzaXR5TikNCmRmX2VnbzMkdW5pdmVyc2l0eU48LWdzdWIoJ1ZVJyw2LGRmX2VnbzMkdW5pdmVyc2l0eU4pDQoNCiNGaW5hbCBjaGVjaw0KdGFibGUoZGZfZWdvMyR1bml2ZXJzaXR5LGRmX2VnbzMkdW5pdmVyc2l0eU4pDQoNCmBgYA0KDQpgYGB7cixldmFsPUZ9DQojVGhlIG5leHQgdmFyaWFibGUgdG8gdHJhbnNmb3JtIGlzICdmdW5jdGlvbicNCiNUaGUgc2FtZSBsb2dpYyBpcyBhcHBsaWVkIGhlcmUsIHRoZSBnb2FsIGlzIG9uZSB2YXJpYWJsZSB3aGljaCBpbmRpY2F0ZXMgd2hpY2ggZnVuY3Rpb24gZWFjaCBzb2Npb2xvZ2lzdCBoYWQNCiNUaGUgMjAyMiBmdW5jdGlvbiBpcyBwcmVmZXJyZWQgdG8gMjAyNCBhbmQgMjAyNSBmdW5jdGlvbnMsIGFnYWluIHdpdGggdGhlIGFyZ3VtZW50IHRoYXQgYW55IGNoYW5nZXMgaW4gZnVuY3Rpb24NCiN3aGljaCBvY2N1cmVkIHRoaXMgeWVhciAoMjAyNSkgb3IgbGFzdCB5ZWFyICgyMDI0KSBjb21wYXJlZCB0byAyMDIyIHdvdWxkIGhhdmUgaGFkIGxlc3Mgb2YgYW4gZWZmZWN0IG9uIHRoZSANCiNwdWJsaWNhdGlvbiByZWNvcmQgYW5kIGNvbGxhYm9yYXRpb25zIG9mIGVhY2ggc29jaW9sb2dpc3QgdGhhbiB0aGUgZnVuY3Rpb24gdGhleSBoYWQgaW4gMjAyMi4NCg0KI0JlY2F1c2Ugb2YgdGhlIG1vcmUgaGV0ZXJvZ2Vub3VzIHN0cmluZyBsZW5ndGggb2YgdGhlIGZ1bmN0aW9uIHZhcmlhYmxlcyBhcyBjb21wYXJlZCB0byB0aGUgdW5pdmVyc2l0eSANCiN2YXJpYWJsZXMsIHRoZXkgYXJlIGZpcnN0IG1hZGUgaW50byBudW1iZXJzLCB0aGVuIGNvbWJpbmVkLCB0aGVuIHRoZSBmaXJzdCBpcyBzZWxlY3RlZCwgd2hpY2ggaXMgdGhlbg0KI3RyYW5zZm9ybWVkIGJhY2sgaW50byB0aGUgb3JpZ2luYWwgc3RyaW5nDQoNCiNNYWtpbmcgdGhlIGZ1bmN0aW9uIHZhcmlhYmxlcyBpbnRvIG51bWJlcnMNCiMyMDIyIChmdW5jc3ViIGlzIHVzZWQgYmVjYXVzZSBpdCBoYXMgdGhlIGltcHV0ZWQgbWlzc2luZ3MpDQpkZl9lZ28zJGZ1bmMyMjwtZGZfZWdvMyRmdW5jc3ViDQpkZl9lZ28zJGZ1bmMyMjwtZ3N1YignUGhEIENhbmRpZGF0ZScsJzAnLGRmX2VnbzMkZnVuYzIyKQ0KZGZfZWdvMyRmdW5jMjI8LWdzdWIoJ1Bvc3Rkb2N0b3JhbCBSZXNlYXJjaGVyJywnMScsZGZfZWdvMyRmdW5jMjIpDQpkZl9lZ28zJGZ1bmMyMjwtZ3N1YignTGVjdHVyZXInLCcyJyxkZl9lZ28zJGZ1bmMyMikNCmRmX2VnbzMkZnVuYzIyPC1nc3ViKCdSZXNlYXJjaGVyJywnMycsZGZfZWdvMyRmdW5jMjIpDQpkZl9lZ28zJGZ1bmMyMjwtZ3N1YignQXNzaXN0YW50IFByb2Zlc3NvcicsJzQnLGRmX2VnbzMkZnVuYzIyKQ0KZGZfZWdvMyRmdW5jMjI8LWdzdWIoJ0Fzc29jaWF0ZSBQcm9mZXNzb3InLCc1JyxkZl9lZ28zJGZ1bmMyMikNCmRmX2VnbzMkZnVuYzIyPC1nc3ViKCdGdWxsIFByb2Zlc3NvcicsJzYnLGRmX2VnbzMkZnVuYzIyKQ0KDQojMjAyNA0KZGZfZWdvMyRmdW5jMjQ8LWRmX2VnbzMkZnVuY3RpZS4yNA0KZGZfZWdvMyRmdW5jMjQ8LWdzdWIoJ1BoRCBDYW5kaWRhdGUnLCcwJyxkZl9lZ28zJGZ1bmMyNCkNCmRmX2VnbzMkZnVuYzI0PC1nc3ViKCdQb3N0ZG9jdG9yYWwgUmVzZWFyY2hlcicsJzEnLGRmX2VnbzMkZnVuYzI0KQ0KZGZfZWdvMyRmdW5jMjQ8LWdzdWIoJ0xlY3R1cmVyJywnMicsZGZfZWdvMyRmdW5jMjQpDQpkZl9lZ28zJGZ1bmMyNDwtZ3N1YignUmVzZWFyY2hlcicsJzMnLGRmX2VnbzMkZnVuYzI0KQ0KZGZfZWdvMyRmdW5jMjQ8LWdzdWIoJ0Fzc2lzdGFudCBQcm9mZXNzb3InLCc0JyxkZl9lZ28zJGZ1bmMyNCkNCmRmX2VnbzMkZnVuYzI0PC1nc3ViKCdBc3NvY2lhdGUgUHJvZmVzc29yJywnNScsZGZfZWdvMyRmdW5jMjQpDQpkZl9lZ28zJGZ1bmMyNDwtZ3N1YignRnVsbCBQcm9mZXNzb3InLCc2JyxkZl9lZ28zJGZ1bmMyNCkNCg0KIzIwMjUNCmRmX2VnbzMkZnVuYzI1PC1kZl9lZ28zJGZ1bmN0aWUuMjUNCmRmX2VnbzMkZnVuYzI1PC1nc3ViKCdQaEQgQ2FuZGlkYXRlJywnMCcsZGZfZWdvMyRmdW5jMjUpDQpkZl9lZ28zJGZ1bmMyNTwtZ3N1YignUG9zdGRvY3RvcmFsIFJlc2VhcmNoZXInLCcxJyxkZl9lZ28zJGZ1bmMyNSkNCmRmX2VnbzMkZnVuYzI1PC1nc3ViKCdMZWN0dXJlcicsJzInLGRmX2VnbzMkZnVuYzI1KQ0KZGZfZWdvMyRmdW5jMjU8LWdzdWIoJ1Jlc2VhcmNoZXInLCczJyxkZl9lZ28zJGZ1bmMyNSkNCmRmX2VnbzMkZnVuYzI1PC1nc3ViKCdBc3Npc3RhbnQgUHJvZmVzc29yJywnNCcsZGZfZWdvMyRmdW5jMjUpDQpkZl9lZ28zJGZ1bmMyNTwtZ3N1YignQXNzb2NpYXRlIFByb2Zlc3NvcicsJzUnLGRmX2VnbzMkZnVuYzI1KQ0KZGZfZWdvMyRmdW5jMjU8LWdzdWIoJ0Z1bGwgUHJvZmVzc29yJywnNicsZGZfZWdvMyRmdW5jMjUpDQoNCiNDaGVjayB2YWx1ZXMgaWYgdGhlIHZhbHVlcyBjb3JyZXNwb25kDQpmdW5jdGlvbkNoZWNrPC1jYmluZC5kYXRhLmZyYW1lKA0KICBkZl9lZ28zJGZ1bmNzdWIsZGZfZWdvMyRmdW5jMjIsZGZfZWdvMyRmdW5jdGllLjI0LGRmX2VnbzMkZnVuYzI0LGRmX2VnbzMkZnVuY3RpZS4yNSxkZl9lZ28zJGZ1bmMyNSkNCnZpZXcoZnVuY3Rpb25DaGVjaykNCnJtKGZ1bmN0aW9uQ2hlY2spDQoNCiNUaGUgdmFsdWVzIGFyZSBhcyBpbnRlbmRlZCwgbm93IHRvIG1lcmdlIHRoZSBudW1iZXJzLCBleHRyYWN0IHRoZSBmaXJzdCBhbmQgbWFrZSBpdCBiYWNrIGludG8gYSB3b3JkDQpkZl9lZ28zJGZ1bmN0aW9uTjwtcGFzdGUoZGZfZWdvMyRmdW5jMjIsZGZfZWdvMyRmdW5jMjQsZGZfZWdvMyRmdW5jMjUpDQpkZl9lZ28zJGZ1bmN0aW9uTjwtZ3N1YignTkEnLCcnLGRmX2VnbzMkZnVuY3Rpb25OKQ0KZGZfZWdvMyRmdW5jdGlvbk48LWdzdWIoJyAnLCcnLGRmX2VnbzMkZnVuY3Rpb25OKQ0KZGZfZWdvMyRmdW5jdGlvbk48LXN1YnN0cihkZl9lZ28zJGZ1bmN0aW9uTixzdGFydD0xLHN0b3A9MSkNCnRhYmxlKGRmX2VnbzMkZnVuY3Rpb25OLHVzZU5BPSdhbHdheXMnKQ0KDQojTm93IHRvIG1ha2UgdGhlIHZhcmlhYmxlIGFjdHVhbGx5IG51bWVyaWMNCmRmX2VnbzMkZnVuY3Rpb25OPC1nc3ViKCcwJywwLGRmX2VnbzMkZnVuY3Rpb25OKQ0KZGZfZWdvMyRmdW5jdGlvbk48LWdzdWIoJzEnLDEsZGZfZWdvMyRmdW5jdGlvbk4pDQpkZl9lZ28zJGZ1bmN0aW9uTjwtZ3N1YignMicsMixkZl9lZ28zJGZ1bmN0aW9uTikNCmRmX2VnbzMkZnVuY3Rpb25OPC1nc3ViKCczJywzLGRmX2VnbzMkZnVuY3Rpb25OKQ0KZGZfZWdvMyRmdW5jdGlvbk48LWdzdWIoJzQnLDQsZGZfZWdvMyRmdW5jdGlvbk4pDQpkZl9lZ28zJGZ1bmN0aW9uTjwtZ3N1YignNScsNSxkZl9lZ28zJGZ1bmN0aW9uTikNCmRmX2VnbzMkZnVuY3Rpb25OPC1nc3ViKCc2Jyw2LGRmX2VnbzMkZnVuY3Rpb25OKQ0KdGFibGUoZGZfZWdvMyRmdW5jdGlvbk4sdXNlTkE9J2Fsd2F5cycpDQoNCiNBbmQgY3JlYXRlIGEgc3RyaW5nIHZlcnNpb24gZm9yIGVhc3kgcmVmZXJlbmNlDQpkZl9lZ28zJGZ1bmN0aW9uUzwtZGZfZWdvMyRmdW5jdGlvbk4NCmRmX2VnbzMkZnVuY3Rpb25TPC1nc3ViKCcwJywnUGhEIENhbmRpZGF0ZScsZGZfZWdvMyRmdW5jdGlvblMpDQpkZl9lZ28zJGZ1bmN0aW9uUzwtZ3N1YignMScsJ1Bvc3Rkb2N0b3JhbCBSZXNlYXJjaGVyJyxkZl9lZ28zJGZ1bmN0aW9uUykNCmRmX2VnbzMkZnVuY3Rpb25TPC1nc3ViKCcyJywnTGVjdHVyZXInLGRmX2VnbzMkZnVuY3Rpb25TKQ0KZGZfZWdvMyRmdW5jdGlvblM8LWdzdWIoJzMnLCdSZXNlYXJjaGVyJyxkZl9lZ28zJGZ1bmN0aW9uUykNCmRmX2VnbzMkZnVuY3Rpb25TPC1nc3ViKCc0JywnQXNzaXN0YW50IFByb2Zlc3NvcicsZGZfZWdvMyRmdW5jdGlvblMpDQpkZl9lZ28zJGZ1bmN0aW9uUzwtZ3N1YignNScsJ0Fzc29jaWF0ZSBQcm9mZXNzb3InLGRmX2VnbzMkZnVuY3Rpb25TKQ0KZGZfZWdvMyRmdW5jdGlvblM8LWdzdWIoJzYnLCdGdWxsIFByb2Zlc3NvcicsZGZfZWdvMyRmdW5jdGlvblMpDQp0YWJsZShkZl9lZ28zJGZ1bmN0aW9uUyx1c2VOQT0nYWx3YXlzJykNCg0KI0NoZWNrIGlmIHRoZSB2YWx1ZXMgYXJlIGNvcnJlY3QNCmZ1bmN0aW9uQ2hlY2s8LWNiaW5kLmRhdGEuZnJhbWUoDQogIGRmX2VnbzMkZnVuY3N1YixkZl9lZ28zJGZ1bmMyMixkZl9lZ28zJGZ1bmN0aWUuMjQsZGZfZWdvMyRmdW5jMjQsZGZfZWdvMyRmdW5jdGllLjI1LGRmX2VnbzMkZnVuYzI1LA0KICBkZl9lZ28zJGZ1bmN0aW9uTixkZl9lZ28zJGZ1bmN0aW9uUykNCnZpZXcoZnVuY3Rpb25DaGVjaykNCnJtKGZ1bmN0aW9uQ2hlY2spDQoNCiNUdXJucyBvdXQgdGhlcmUgYXJlIHN0aWxsIDEzIG1pc3NpbmdzLCB0aGVzZSBhcmUgbWFya2VkIE5BDQpkZl9lZ28zWzQ2LCdmdW5jdGlvbk4nXTwtTkENCmRmX2VnbzNbNDYsJ2Z1bmN0aW9uUyddPC1OQQ0KZGZfZWdvM1sxMjUsJ2Z1bmN0aW9uTiddPC1OQQ0KZGZfZWdvM1sxMjUsJ2Z1bmN0aW9uUyddPC1OQQ0KZGZfZWdvM1sxNzQsJ2Z1bmN0aW9uTiddPC1OQQ0KZGZfZWdvM1sxNzQsJ2Z1bmN0aW9uUyddPC1OQQ0KZGZfZWdvM1sxODgsJ2Z1bmN0aW9uTiddPC1OQQ0KZGZfZWdvM1sxODgsJ2Z1bmN0aW9uUyddPC1OQQ0KZGZfZWdvM1sxOTUsJ2Z1bmN0aW9uTiddPC1OQQ0KZGZfZWdvM1sxOTUsJ2Z1bmN0aW9uUyddPC1OQQ0KZGZfZWdvM1syMzcsJ2Z1bmN0aW9uTiddPC1OQQ0KZGZfZWdvM1syMzcsJ2Z1bmN0aW9uUyddPC1OQQ0KZGZfZWdvM1syNDgsJ2Z1bmN0aW9uTiddPC1OQQ0KZGZfZWdvM1syNDgsJ2Z1bmN0aW9uUyddPC1OQQ0KZGZfZWdvM1syNzQsJ2Z1bmN0aW9uTiddPC1OQQ0KZGZfZWdvM1syNzQsJ2Z1bmN0aW9uUyddPC1OQQ0KZGZfZWdvM1szMjQsJ2Z1bmN0aW9uTiddPC1OQQ0KZGZfZWdvM1szMjQsJ2Z1bmN0aW9uUyddPC1OQQ0KZGZfZWdvM1szNTUsJ2Z1bmN0aW9uTiddPC1OQQ0KZGZfZWdvM1szNTUsJ2Z1bmN0aW9uUyddPC1OQQ0KZGZfZWdvM1szNzUsJ2Z1bmN0aW9uTiddPC1OQQ0KZGZfZWdvM1szNzUsJ2Z1bmN0aW9uUyddPC1OQQ0KZGZfZWdvM1s0MDMsJ2Z1bmN0aW9uTiddPC1OQQ0KZGZfZWdvM1s0MDMsJ2Z1bmN0aW9uUyddPC1OQQ0KZGZfZWdvM1s0NTcsJ2Z1bmN0aW9uTiddPC1OQQ0KZGZfZWdvM1s0NTcsJ2Z1bmN0aW9uUyddPC1OQQ0KDQojQ2hlY2sgYWdhaW4NCnRhYmxlKGRmX2VnbzMkZnVuY3Rpb25OLGRmX2VnbzMkZnVuY3Rpb25TLHVzZU5BPSdhbHdheXMnKQ0KDQojTm93IHRoZSBzdHJpbmcgYW5kIG51bWVyaWMgZnVuY3Rpb24gdmFyaWFibGVzIGFyZSBhcyBpbnRlbmRlZA0KYGBgDQoNCmBgYHtyLGV2YWw9Rn0NCiNMYXN0bHkgdGhlIGdlbmRlciB2YXJpYWJsZSB3YXMgbWFkZSBpbnRvIGEgZHVtbXkNCmRmX2VnbzMkZ2VuZGVyTjwtZGZfZWdvMyRnZW5kZXINCmRmX2VnbzMkZ2VuZGVyTjwtZ3N1YignZmVtYWxlJywwLGRmX2VnbzMkZ2VuZGVyTikNCmRmX2VnbzMkZ2VuZGVyTjwtZ3N1YignbWFsZScsMSxkZl9lZ28zJGdlbmRlck4pDQoNCiNDaGVjayBpZiB0aGUgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIG9yaWdpbmFsIHZhcmlhYmxlDQp0YWJsZShkZl9lZ28zJGdlbmRlcixkZl9lZ28zJGdlbmRlck4sdXNlTkE9J2Fsd2F5cycpDQoNCiNUaGV5IGRvLCB0aGUgZ2VuZGVyIGR1bW15IGlzIG1hZGUNCmBgYA0KDQpgYGB7cixldmFsPUZ9DQojVGhlIGxhc3Qgc3RlcCBpcyB0byBlbnN1cmUgdGhlcmUgYXJlIG5vIGR1cGxpY2F0ZSBjYXNlcyBpbiB0aGUgZGF0YXNldCBhbmQgZGVsZXRlIGFueSByZW1haW5pbmcgbWlzc2luZ3MNCnRhYmxlKGRmX2VnbzMkdW5hYW0pDQoNCiNUaGVyZSBhcmUgYSBmZXcgZHVwbGljYXRlcywgdGhleSBhcmUgcmVtb3ZlZA0KZGZfZWdvRjwtZGZfZWdvM1shZHVwbGljYXRlZChkZl9lZ28zW2MoJ3VuYWFtJyldKSwgXQ0KDQojQ2hlY2tpbmcgZm9yIG1pc3NpbmdzIGluIG91ciBrZXkgdmFyaWFibGVzDQp0YWJsZShkZl9lZ28zJGdlbmRlck4sdXNlTkE9J2Fsd2F5cycpDQp0YWJsZShkZl9lZ28zJGZ1bmN0aW9uTix1c2VOQT0nYWx3YXlzJykNCnRhYmxlKGRmX2VnbzMkdW5pdmVyc2l0eU4sdXNlTkE9J2Fsd2F5cycpDQp0YWJsZShkZl9lZ28zJGljc0FmZmlsaWF0ZSx1c2VOQT0nYWx3YXlzJykNCnRhYmxlKGRmX2VnbzMkaWNzR3JhZHVhdGUsdXNlTkE9J2Fsd2F5cycpDQp0YWJsZShkZl9lZ28zJGljc0FueSx1c2VOQT0nYWx3YXlzJykNCg0KI1RoZXJlIGFyZSBzdGlsbCAxMyBzb2Npb2xvZ2lzdHMgd2l0aCBhIG1pc3NpbmcgdmFsdWUgZm9yIHRoZSBmdW5jdGlvbiB2YXJpYWJsZSwgdGhleSBhcmUgZGVsZXRlZCBsaXN0d2lzZQ0KI2RmX2Vnb0Y8LWRmX2VnbzNbIWlzLm5hKGRmX2VnbzNbYygnZnVuY3Rpb25OJyldKSwgXQ0KI3NpZW5hRGF0YUNyZWF0ZSBkb2VzbnQgd29yayBpZiB5b3UgZGVsZXRlIG1pc3NpbmdzIGxpc3R3aXNlLCBmdW5jdGlvbiB3YXMgYSByb2J1c3RuZXNzIGNoZWNrIGFueXdheXMNCg0KI05vdyB3ZSBoYXZlIHRoZSBmaW5hbCBlZ28gbGV2ZWwgdmFyaWFibGUgZGF0YWZyYW1lLCBkZl9lZ29GDQpgYGANCg0KYGBge3IsZXZhbD1GfQ0KI1dpdGggdGhlIGRhdGEgY2xlYW5lZCwgaXQgY2FuIG5vdyBiZSBtYWRlIGludG8gYW4gUlNpZW5hIGRhdGEgb2JqZWN0DQojU29tZSBzdGlsbCBuZWVkIHRvIGJlIG1hcmtlZCBhcyBudW1lcmljLCB3aGljaCBkb2VzIG5vdCBjaGFuZ2UgdGhlIHZhbHVlcyBpbiB0aGlzIGNhc2UNCmRmX2Vnb0YkdW5pdmVyc2l0eU48LWFzLm51bWVyaWMoZGZfZWdvRiR1bml2ZXJzaXR5TikNCnVuaXZlcnNpdHlOPC1jb0NvdmFyKGRmX2Vnb0YkdW5pdmVyc2l0eU4sY2VudGVyZWQ9RkFMU0UpDQpkZl9lZ29GJGZ1bmN0aW9uTjwtYXMubnVtZXJpYyhkZl9lZ29GJGZ1bmN0aW9uTikNCmZ1bmN0aW9uTzwtY29Db3ZhcihkZl9lZ29GJGZ1bmN0aW9uTixjZW50ZXJlZD1GQUxTRSkNCmRmX2Vnb0YkZ2VuZGVyTjwtYXMubnVtZXJpYyhkZl9lZ29GJGdlbmRlck4pDQpnZW5kZXJEPC1jb0NvdmFyKGRmX2Vnb0YkZ2VuZGVyTixjZW50ZXJlZD1GQUxTRSkNCmljc2FueUQ8LWNvQ292YXIoZGZfZWdvRiRpY3NBbnksY2VudGVyZWQ9RkFMU0UpDQppY3NhZmZpbEQ8LWNvQ292YXIoZGZfZWdvRiRpY3NBZmZpbGlhdGUsY2VudGVyZWQ9RkFMU0UpDQppY3NncmFkRDwtY29Db3ZhcihkZl9lZ29GJGljc0dyYWR1YXRlLGNlbnRlcmVkPUZBTFNFKQ0KDQojTWFraW5nIHRoZSBkYXRhIG9iamVjdA0KY29sbGFibmV0MTwtc2llbmFEYXRhQ3JlYXRlKG5ldCwgdW5pdmVyc2l0eU4sIGZ1bmN0aW9uTywgZ2VuZGVyRCwgaWNzYW55RCwgaWNzYWZmaWxELCBpY3NncmFkRCkNCnByaW50MDFSZXBvcnQoY29sbGFibmV0MSkNCg0KI0NyZWF0ZSBtYWluIGFsZ29yaXRobQ0KYWxnb01haW48LXNpZW5hQWxnb3JpdGhtQ3JlYXRlKCkNCg0KI05vdyB0byBzcGVjaWZ5IHRoZSBtb2RlbHMNCg0KI0EgZmlyc3QgbW9kZWwgaW5jbHVkaW5nIG9ubHkgaWNzYW55DQplZmZlY3RzMTwtZ2V0RWZmZWN0cyhjb2xsYWJuZXQxKQ0KI0VmZmVjdHMgb2YgZWdvIGNoYXJhY3RlcmlzdGljcw0KICBlZmZlY3RzMTwtaW5jbHVkZUVmZmVjdHMoZWZmZWN0czEsc2FtZVgsbmFtZT0nbmV0JyxpbnRlcmFjdGlvbjE9J2ljc2FueUQnKQ0KDQojRXN0aW1hdGUgbW9kZWwgMQ0KdGVzdEVzdGltYXRlMTwtc2llbmEwNyhhbGdvTWFpbixkYXRhPWNvbGxhYm5ldDEsZWZmZWN0cz1lZmZlY3RzMSxyZXR1cm5EZXBzPVRSVUUpDQp0ZXN0RXN0aW1hdGUxDQogIA0KI0Egc2Vjb25kIG1vZGVsIGluY2x1ZGluZyBpY3NhbnkgYW5kIHRoZSB0aHJlZSBjb250cm9scw0KZWZmZWN0czI8LWdldEVmZmVjdHMoY29sbGFibmV0MSkNCiNFZmZlY3RzIG9mIGVnbyBjaGFyYWN0ZXJpc3RpY3MNCiAgZWZmZWN0czI8LWluY2x1ZGVFZmZlY3RzKGVmZmVjdHMyLHNhbWVYLG5hbWU9J25ldCcsaW50ZXJhY3Rpb24xPSdnZW5kZXJEJykNCiAgZWZmZWN0czI8LWluY2x1ZGVFZmZlY3RzKGVmZmVjdHMyLHNhbWVYLG5hbWU9J25ldCcsaW50ZXJhY3Rpb24xPSd1bml2ZXJzaXR5TicpDQogIGVmZmVjdHMyPC1pbmNsdWRlRWZmZWN0cyhlZmZlY3RzMixzYW1lWCxuYW1lPSduZXQnLGludGVyYWN0aW9uMT0naWNzYW55RCcpDQogIGVmZmVjdHMyPC1pbmNsdWRlRWZmZWN0cyhlZmZlY3RzMix1bmVxdWFsWCxuYW1lPSduZXQnLGludGVyYWN0aW9uMT0nZnVuY3Rpb25PJykNCiAgDQojRXN0aW1hdGUgbW9kZWwgMg0KICB0ZXN0RXN0aW1hdGUyPC1zaWVuYTA3KGFsZ29NYWluLGRhdGE9Y29sbGFibmV0MSxlZmZlY3RzPWVmZmVjdHMyLHJldHVybkRlcHM9VFJVRSkNCiAgdGVzdEVzdGltYXRlMg0KICANCiNBIHRoaXJkIG1vZGVsIGluY2x1ZGluZyB0aGUgdHdvIHNlcGFyYXRlIGljcyB2YXJpYWJsZXMgYW5kIGNvbnRyb2xzDQplZmZlY3RzMzwtZ2V0RWZmZWN0cyhjb2xsYWJuZXQxKQ0KI0VmZmVjdHMgb2YgZWdvIGNoYXJhY3RlcmlzdGljcw0KICBlZmZlY3RzMzwtaW5jbHVkZUVmZmVjdHMoZWZmZWN0czMsc2FtZVgsbmFtZT0nbmV0JyxpbnRlcmFjdGlvbjE9J2dlbmRlckQnKQ0KICBlZmZlY3RzMzwtaW5jbHVkZUVmZmVjdHMoZWZmZWN0czMsc2FtZVgsbmFtZT0nbmV0JyxpbnRlcmFjdGlvbjE9J3VuaXZlcnNpdHlOJykNCiAgZWZmZWN0czM8LWluY2x1ZGVFZmZlY3RzKGVmZmVjdHMzLHNhbWVYLG5hbWU9J25ldCcsaW50ZXJhY3Rpb24xPSdpY3NhZmZpbEQnKQ0KICBlZmZlY3RzMzwtaW5jbHVkZUVmZmVjdHMoZWZmZWN0czMsc2FtZVgsbmFtZT0nbmV0JyxpbnRlcmFjdGlvbjE9J2ljc2dyYWREJykNCiAgZWZmZWN0czM8LWluY2x1ZGVFZmZlY3RzKGVmZmVjdHMzLHVuZXF1YWxYLG5hbWU9J25ldCcsaW50ZXJhY3Rpb24xPSdmdW5jdGlvbk8nKQ0KICANCiNFc3RpbWF0ZSBtb2RlbCAzDQogIHRlc3RFc3RpbWF0ZTM8LXNpZW5hMDcoYWxnb01haW4sZGF0YT1jb2xsYWJuZXQxLGVmZmVjdHM9ZWZmZWN0czMscmV0dXJuRGVwcz1UUlVFKQ0KICB0ZXN0RXN0aW1hdGUzDQoNCg0KYGBgDQoNCmBgYHtyLGV2YWw9Rn0NCiNHb29kbmVzcyBvZiBGaXQgb2YgZmlyc3QgdHdvIG1vZGVsIGF0dGVtcHRzDQoNCiNBdHRlbXB0IDEsIHdpdGggb25seSBpY3NhbnkNCm1vZGVsMWdvZjEgPC0gc2llbmFHT0YodGVzdEVzdGltYXRlMSwgSW5kZWdyZWVEaXN0cmlidXRpb24sIHZlcmJvc2UgPSBGQUxTRSwgam9pbiA9IFRSVUUsIHZhck5hbWUgPSAibmV0IikNCm1vZGVsMWdvZjENCnBsb3QobW9kZWwxZ29mMSkNCg0KI0F0dGVtcHQgMiwgd2l0aCBpY3NhbnkgYW5kIHN0cnVjdHVyYWwgZWZmZWN0cw0KbW9kZWwyZ29mMSA8LSBzaWVuYUdPRih0ZXN0RXN0aW1hdGUyLCBJbmRlZ3JlZURpc3RyaWJ1dGlvbiwgdmVyYm9zZSA9IEZBTFNFLCBqb2luID0gVFJVRSwgdmFyTmFtZSA9ICJuZXQiKQ0KbW9kZWwyZ29mMQ0KcGxvdChtb2RlbDJnb2YxKQ0KDQojQXR0ZW1wdCAzLCB3aXRoIHNlcGFyYXRlIGljcyB2YXJpYWJsZXMgYW5kIGNvbnRyb2xzDQptb2RlbDNnb2YxIDwtIHNpZW5hR09GKHRlc3RFc3RpbWF0ZTMsIEluZGVncmVlRGlzdHJpYnV0aW9uLCB2ZXJib3NlID0gRkFMU0UsIGpvaW4gPSBUUlVFLCB2YXJOYW1lID0gIm5ldCIpDQptb2RlbDNnb2YxDQpwbG90KG1vZGVsM2dvZjEpDQoNCmBgYA0KDQpgYGB7cixldmFsPUZ9DQojRm9yIHRoZSBkZWZpbml0aXZlIG1vZGVsLCBhIHJlbGF0aXZlIGluZmx1ZW5jZSBhbmFseXNpcyBpcyB1c2VmdWwgdG8gY29tcGFyZSB0aGUgZWZmZWN0cw0KDQoNCg0KYGBgDQoNCmBgYHtyLGV2YWw9Rn0NCiNWaXN1YWxpc2luZyB0aGUgbmV0d29yaw0KDQojVjEgV2l0aCBpc29sYXRlcw0KbmV0dmlzMSA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeCgNCiAgc25kYXRhMSRuZXRzWzIsLF0sDQogIG1vZGUgPSBjKCJkaXJlY3RlZCIpLA0KICB3ZWlnaHRlZCA9IE5VTEwsDQogIGRpYWcgPSBGQUxTRSwNCiAgYWRkLmNvbG5hbWVzID0gTlVMTCwpDQoNCnBsb3QobmV0dmlzMSwNCiAgdmVydGV4LmNvbG9yID0gaWZlbHNlKGRmTmlzbyRpY3NBbnkgPT0gMSwgInJlZCIsICJibHVlIiksDQogIHZlcnRleC5sYWJlbCA9IE5BLA0KICB2ZXJ0ZXguc2l6ZSA9IDUsDQogIGVkZ2Uud2lkdGggPSAwLjIsDQogIGVkZ2UuYXJyb3cuc2l6ZSA9MC4yKQ0KDQojVjIgV2l0aG91dCBpc29sYXRlcw0Kbm9pc29sYXRlcyA9IHJvd1N1bXMoc25kYXRhMSRuZXRzWzIsLF0pID4gMA0KbmV0TmlzbyA9IHNuZGF0YTEkbmV0c1syLG5vaXNvbGF0ZXMsbm9pc29sYXRlc10NCmRmTmlzbyA9IGRmX2Vnb0Zbbm9pc29sYXRlcywgXQ0KDQpuZXR2aXMyIDwtIGlncmFwaDo6Z3JhcGhfZnJvbV9hZGphY2VuY3lfbWF0cml4KA0KICBuZXROaXNvLA0KICBtb2RlID0gYygiZGlyZWN0ZWQiKSwNCiAgd2VpZ2h0ZWQgPSBOVUxMLA0KICBkaWFnID0gRkFMU0UsDQogIGFkZC5jb2xuYW1lcyA9IE5VTEwsKQ0KDQpwbG90KG5ldHZpczIsDQogIHZlcnRleC5jb2xvciA9IGlmZWxzZShkZk5pc28kaWNzQW55ID09IDEsICJyZWQiLCAiYmx1ZSIpLA0KICB2ZXJ0ZXgubGFiZWwgPSBOQSwNCiAgdmVydGV4LnNpemUgPSA1LA0KICBlZGdlLndpZHRoID0gMC4yLA0KICBlZGdlLmFycm93LnNpemUgPTAuMikNCg0KDQpgYGANCg0KYGBge3IsZXZhbD1GfQ0KI05vdyB0byB0ZXN0IHdoZXRoZXIgdGhlIG5ldHdvcmsgaGFzIGEgc2lnbmlmaWNhbnQgYW1vdW50IG9mIGNsdXN0ZXJpbmcNCiNGaXJzdCBjYWxjdWxhdGUgdGhlIGdsb2JhbCBjbHVzdGVyaW5nIGNvZWZmaWNpZW50IGFuZCB0cmFuc2l0aXZpdHkgcmF0aW8gZm9yIG91ciBuZXR3b3JrDQojVGhlbiBzaW11bGF0ZSBuZXR3b3JrcyB3aXRob3V0IGNsdXN0ZXJpbmcNCiNUaGVuIHNlZSBpZiBvdXIgdmFsdWVzIGFyZSBzaWduaWZpY2FudGx5IGhpZ2hlcg0KDQojQ2FsY3VsYXRpbmcgdGhlIGNsdXN0ZXJpbmcgY29lZmZpY2llbnQNCnRyYW5zaXRpdml0eShuZXR2aXMyKQ0KdHJhbnNpdGl2aXR5KG5ldHZpczIsdHlwZT0nYXZlcmFnZScpDQoNCiNTcGVjaWZ5aW5nIHRoZSBtb2RlbHMgdG8gc2ltdWxhdGUgYmFzZWQgb24gdGhlIGZpbmFsIFJTaWVuYSBtb2RlbA0KZWZmZWN0c1NpbTwtZWZmZWN0cyMNCiAgZWZmZWN0c1NpbTwtaW5jbHVkZUVmZmVjdHMoZWZmZWN0c1NpbSxTdHJFRkZFQ1QsaW5pdGlhbFZhbHVlID0gDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTU9ERUwkdGhldGFbd2hpY2goTU9ERUwkZWZmZWN0cyRzaG9ydE5hbWUgPT0gIlN0ckVGRkVDVCIpXSkpDQogIGVmZmVjdHNTaW08LWluY2x1ZGVFZmZlY3RzKGVmZmVjdHNTaW0sRWdvRUZGRUNULGludGVyYWN0aW9uMT0nVkFSSUFCTEUnLGluaXRpYWxWYWx1ZSA9IA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1PREVMJHRoZXRhW3doaWNoKE1PREVMJGVmZmVjdHMkc2hvcnROYW1lID09ICJFZ29FRkZFQ1QiKV0pKQ0KDQojRml4IGVmZmVjdHMgb2YgYWxsIHZhcmlhYmxlcw0KZWZmZWN0c1NpbSRmaXhbZWZmZWN0c1NpbSRpbmNsdWRlID09IFRSVUVdIDwtIFRSVUUNCg0KI0ludHJvZHVjZSBoaWdoZXIgYW5kIG5vIGVmZmVjdCB2YXJpYXRpb25zDQplZmZlY3RzU2ltMCA8LSBlZmZlY3RzU2ltSEkgPC0gZWZmZWN0c1NpbQ0KDQojQWRqdXN0IENPTlRST0xMRUQgVkFSSUFCTEUgZWZmZWN0IGluIGFsdCBzaW11bGF0aW9ucw0KZWZmZWN0c1NpbTAgPC0gc2V0RWZmZWN0KGVmZmVjdHNTaW0sIEVGRkVDVCwgaW5pdGlhbFZhbHVlID0gMCwgZml4ID0gVFJVRSkNCmVmZmVjdHNTaW1ISSA8LSBzZXRFZmZlY3QoZWZmZWN0c1NpbSwgRUZGRUNULCBpbml0aWFsVmFsdWUgPSANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNT0RFTCR0aGV0YVt3aGljaChNT0RFTCRlZmZlY3RzJHNob3J0TmFtZSA9PSAiRUZGRUNUIildICogMiwgZml4ID0gVFJVRSkNCg0KI01ha2Ugc2ltdWxhdGlvbiBhbGdvcml0aG0NCml0ZXJTaW08LTEwMDANCmFsZ29TaW0gPC0gc2llbmFBbGdvcml0aG1DcmVhdGUoDQogICAgcHJvam5hbWUgPSAnc2ltdWxhdGlvbicsDQogICAgY29uZCA9IEZBTFNFLA0KICAgIHVzZVN0ZEluaXRzID0gRkFMU0UsIG5zdWIgPSAwLA0KICAgIG4zID0gaXRlclNpbSwgDQogICAgc2VlZD0yNDI0NTIsICMgc2VlZCBmb3IgcmVwbGljYXRpb24NCiAgICBzaW1Pbmx5ID0gVFJVRSkNCg0KYGBgDQoNCg0KYGBge3IsZXZhbD1GfQ0KI0NhcnJ5aW5nIG91dCB0aGUgc2ltdWxhdGlvbnMgYW5kIHN0b3JpbmcgYm90aCB0cmFuc2l0aXZpdHkgaW5kaWNlcyBmb3IgdXNlIGFzIGNsdXN0ZXJpbmcgaW5kaWNhdG9ycw0KI01ha2UgdmVjdG9yIHRvIHN0b3JlIHRyYW5zaXRpdml0eQ0KDQp0cmFuc1NpbUcgPC0gdHJhbnNTaW1HMCA8LSB0cmFuc1NpbUdISSA8LSByZXAoMCwgaXRlclNpbSkNCnRyYW5zU2ltQSA8LSB0cmFuc1NpbUEwIDwtIHRyYW5zU2ltQUhJIDwtIHJlcCgwLCBpdGVyU2ltKQ0KDQojU2ltdWxhdGlvbnMgdXNpbmcgZXN0aW1hdGVkIHBhcmFtZXRlcnMNCnNpbU9icyA8LSBzaWVuYTA3KGFsZ29TaW0sICAgICAgIyBzaW11bGF0aW9uIHNldHRpbmdzDQogICAgICAgICAgICAgICAgICAgZGF0YSA9IGNvbGxhYm5ldDEsICAgICAgIyBkYXRhDQogICAgICAgICAgICAgICAgICAgZWZmZWN0cyA9IGVmZmVjdHNTaW0sIyBkZWZpbmVkIGVmZmVjdHMgYW5kIHNldCBwYXJhbWV0ZXJzDQogICAgICAgICAgICAgICAgICAgcmV0dXJuRGVwcyA9IFRSVUUpICAjIHJldHVybiBzaW11bGF0ZWQgbmV0d29ya3MNCiAgDQpzaW0wIDwtIHNpZW5hMDcoYWxnb1NpbSwgICAgICAgIyBzaW11bGF0aW9uIHNldHRpbmdzDQogICAgICAgICAgICAgICAgICAgZGF0YSA9IGNvbGxhYm5ldDEsICAgICAgIyBkYXRhDQogICAgICAgICAgICAgICAgICAgZWZmZWN0cyA9IGVmZmVjdHNTaW0wLCMgZGVmaW5lZCBlZmZlY3RzIGFuZCBzZXQgcGFyYW1ldGVycw0KICAgICAgICAgICAgICAgICAgIHJldHVybkRlcHMgPSBUUlVFKSAgIyByZXR1cm4gc2ltdWxhdGVkIG5ldHdvcmtzDQogIA0Kc2ltSEkgPC0gc2llbmEwNyhhbGdvU2ltLCAgICAgIyBzaW11bGF0aW9uIHNldHRpbmdzDQogICAgICAgICAgICAgICAgICAgZGF0YSA9IGNvbGxhYm5ldDEsICAgICAgIyBkYXRhDQogICAgICAgICAgICAgICAgICAgZWZmZWN0cyA9IGVmZmVjdHNTaW1ISSwjIGRlZmluZWQgZWZmZWN0cyBhbmQgc2V0IHBhcmFtZXRlcnMNCiAgICAgICAgICAgICAgICAgICByZXR1cm5EZXBzID0gVFJVRSkgICMgcmV0dXJuIHNpbXVsYXRlZCBuZXR3b3Jrcw0KYGBgDQoNCmBgYHtyLGV2YWw9Rn0NCiNFeHRyYWN0IHRyYW5zaXRpdml0eSBmcm9tIHNpbXVsYXRpb24gcnVucw0KDQojU2V0IG4NCm48LWxlbmd0aChjb2xsYWJuZXQxJG5vZGVTZXRzW1sxXV0pIA0KDQojT2JzZXJ2ZWQgbW9kZWwNCmZvciAoaSBpbiAxOml0ZXJTaW0pIHsgDQogICNDcmVhdGUgYWRqYWNlbmN5IG1hdHJpeA0KICBhZGogPC0gbWF0cml4KDAsIG4sIG4pDQogIGVkZ2VzIDwtIHNpbU9icyRzaW1zW1tpXV1bWzFdXVtbMV1dW1sxXV0NCiAgYWRqW2VkZ2VzWywgMToyXV0gPC0gZWRnZXNbLCAzXQ0KICANCiAgI0NyZWF0ZSBpZ3JhcGggb2JqZWN0DQogIGdyYXBoU2ltIDwtIGlncmFwaDo6Z3JhcGhfZnJvbV9hZGphY2VuY3lfbWF0cml4KA0KICBhZGpbMiwsXSwNCiAgbW9kZSA9IGMoImRpcmVjdGVkIiksDQogIHdlaWdodGVkID0gTlVMTCwNCiAgZGlhZyA9IEZBTFNFLA0KICBhZGQuY29sbmFtZXMgPSBOVUxMLCkNCiAgDQogICNDYWxjdWxhdGUgYW5kIHN0b3JlIGdsb2JhbCBhbmQgYXZlcmFnZSB0cmFuc2l0aXZpdHkNCiAgdHJhbnNTaW1HW2ldPC10cmFuc2l0aXZpdHkoZ3JhcGhTaW0pDQogIHRyYW5zU2ltQVtpXTwtdHJhbnNpdGl2aXR5KGdyYXBoU2ltLCB0eXBlPSdhdmVyYWdlJykNCn0NCg0KI05vIElDUyBzYW1lWCBtb2RlbA0KZm9yIChpIGluIDE6aXRlclNpbSkgeyANCiAgI0NyZWF0ZSBhZGphY2VuY3kgbWF0cml4DQogIGFkaiA8LSBtYXRyaXgoMCwgbiwgbikNCiAgZWRnZXMgPC0gc2ltMCRzaW1zW1tpXV1bWzFdXVtbMV1dW1sxXV0NCiAgYWRqW2VkZ2VzWywgMToyXV0gPC0gZWRnZXNbLCAzXQ0KICANCiAgI0NyZWF0ZSBpZ3JhcGggb2JqZWN0DQogIGdyYXBoU2ltIDwtIGlncmFwaDo6Z3JhcGhfZnJvbV9hZGphY2VuY3lfbWF0cml4KA0KICBhZGpbMiwsXSwNCiAgbW9kZSA9IGMoImRpcmVjdGVkIiksDQogIHdlaWdodGVkID0gTlVMTCwNCiAgZGlhZyA9IEZBTFNFLA0KICBhZGQuY29sbmFtZXMgPSBOVUxMLCkNCiAgDQogICNDYWxjdWxhdGUgYW5kIHN0b3JlIGdsb2JhbCBhbmQgYXZlcmFnZSB0cmFuc2l0aXZpdHkNCiAgdHJhbnNTaW1HMFtpXTwtdHJhbnNpdGl2aXR5KGdyYXBoU2ltKQ0KICB0cmFuc1NpbUEwW2ldPC10cmFuc2l0aXZpdHkoZ3JhcGhTaW0sIHR5cGU9J2F2ZXJhZ2UnKQ0KfQ0KDQoNCiNIaWdoIElDUyBzYW1lWCBtb2RlbA0KZm9yIChpIGluIDE6aXRlclNpbSkgeyANCiAgI0NyZWF0ZSBhZGphY2VuY3kgbWF0cml4DQogIGFkaiA8LSBtYXRyaXgoMCwgbiwgbikNCiAgZWRnZXMgPC0gc2ltSEkkc2ltc1tbaV1dW1sxXV1bWzFdXVtbMV1dDQogIGFkaltlZGdlc1ssIDE6Ml1dIDwtIGVkZ2VzWywgM10NCiAgDQogICNDcmVhdGUgaWdyYXBoIG9iamVjdA0KICBncmFwaFNpbSA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeCgNCiAgYWRqWzIsLF0sDQogIG1vZGUgPSBjKCJkaXJlY3RlZCIpLA0KICB3ZWlnaHRlZCA9IE5VTEwsDQogIGRpYWcgPSBGQUxTRSwNCiAgYWRkLmNvbG5hbWVzID0gTlVMTCwpDQogIA0KICAjQ2FsY3VsYXRlIGFuZCBzdG9yZSBnbG9iYWwgYW5kIGF2ZXJhZ2UgdHJhbnNpdGl2aXR5DQogIHRyYW5zU2ltR0hJW2ldPC10cmFuc2l0aXZpdHkoZ3JhcGhTaW0pDQogIHRyYW5zU2ltQUhJW2ldPC10cmFuc2l0aXZpdHkoZ3JhcGhTaW0sIHR5cGU9J2F2ZXJhZ2UnKQ0KfQ0KDQojU3VtbWFyaXNlIGZvciBwbG90dGluZywgZmlyc3QgZ2xvYmFsIHRyYW5zaXRpdml0eQ0Kc2ltRGF0YUcgPC0gZGF0YS5mcmFtZShjb25kaXRpb24gPSBjKHJlcCgiT2JzSUNTIiwgaXRlclNpbSksIHJlcCgiMElDUyIsIGl0ZXJTaW0pLCByZXAoIkhJSUNTIiwgaXRlclNpbSkpLA0KICAgICAgICAgICAgICAgICAgICAgICB0cmFuc0cgPSBjKHRyYW5zU2ltRywgdHJhbnNTaW1HMCwgdHJhbnNTaW1HSEkpKQ0Kc2ltRGF0YUckY29uZGl0aW9uIDwtIGZhY3RvcihzaW1EYXRhRyRjb25kaXRpb24sIGxldmVscyA9IGMoIk9ic0lDUyIsICIwSUNTIiwgIkhJSUNTIikpDQoNCiNUaGVuIGF2ZXJhZ2UgdHJhbnNpdGl2aXR5DQpzaW1EYXRhQSA8LSBkYXRhLmZyYW1lKGNvbmRpdGlvbiA9IGMocmVwKCJPYnNJQ1MiLCBpdGVyU2ltKSwgcmVwKCIwSUNTIiwgaXRlclNpbSksIHJlcCgiSElJQ1MiLCBpdGVyU2ltKSksDQogICAgICAgICAgICAgICAgICAgICAgIHRyYW5zQSA9IGModHJhbnNTaW1BLCB0cmFuc1NpbUEwLCB0cmFuc1NpbUFISSkpDQpzaW1EYXRhQSRjb25kaXRpb24gPC0gZmFjdG9yKHNpbURhdGFBJGNvbmRpdGlvbiwgbGV2ZWxzID0gYygiT2JzSUNTIiwgIjBJQ1MiLCAiSElJQ1MiKSkNCg0KI1Bsb3R0aW5nDQp0cmFuc0dwbG90IDwtIGdncGxvdChzaW1EYXRhRywgYWVzKHggPSBjb25kaXRpb24sIHkgPSB0cmFuc0cpKSArDQogIGdlb21fYm94cGxvdCgpICsNCiAgbGFicyh0aXRsZSA9ICJEaXN0cmlidXRpb24gb2YgZ2xvYmFsIHRyYW5zaXRpdml0eSBvdmVyIDEwMDAgaXRlcmF0aW9ucywgYWNyb3NzIHNpbXVsYXRpb24gbW9kZWxzIiwNCiAgICAgICB4ID0gInNpbXVsYXRpb24gbW9kZWwiLA0KICAgICAgIHkgPSAidHJhbnNHIikgKw0KICB5bGltKDAsMSkgKw0KICB0aGVtZV9taW5pbWFsKCkNCg0KdHJhbnNBcGxvdCA8LSBnZ3Bsb3Qoc2ltRGF0YUEsIGFlcyh4ID0gY29uZGl0aW9uLCB5ID0gdHJhbnNBKSkgKw0KICBnZW9tX2JveHBsb3QoKSArDQogIGxhYnModGl0bGUgPSAiRGlzdHJpYnV0aW9uIG9mIGF2ZXJhZ2UgdHJhbnNpdGl2aXR5IG92ZXIgMTAwMCBpdGVyYXRpb25zLCBhY3Jvc3Mgc2ltdWxhdGlvbiBtb2RlbHMiLA0KICAgICAgIHggPSAic2ltdWxhdGlvbiBtb2RlbCIsDQogICAgICAgeSA9ICJ0cmFuc0EiKSArDQogIHlsaW0oMCwxKSArDQogIHRoZW1lX21pbmltYWwoKQ0KDQpgYGA=</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("FinalDataPrep.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
