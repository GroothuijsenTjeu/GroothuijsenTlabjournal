---
title: "Methods"
bibliography: references.bib
output: html_document
---

```{=html}
<style>
body {
  text-align: justify;
  font-family: Times;
}

h1, .h1, h2, .h2, h3, .h3 {
  margin-top: 24px;
  font-family: Times;
}
</style>
```
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Methods

In order to test these hypotheses, data from the open access platform OpenAlex [@Openalex] was used. The data includes individual level characteristics and published works of sociologists and political scientists in the Netherlands. The inclusion of the names of all coauthors of each published paper allows for the construction of collaboration networks using this data, each node is a sociologist and a tie indicates that the two connected sociologists have coauthored a paper in a given wave. Data was collected in 2022, 2024 and 2025, which resulted in some variables having separate and occasionally different values for each year. Given the scope of this study, a selection was made from the data which included only sociologists who were in any of the three available years affiliated with a university in the Netherlands. The dataset as it was used in the analyses included 458 sociologists working at seven different departments. Further descriptive statistics are given per variable.

Custom functions

Several user defined functions were used during the data preparation and analysis. The function ‘fcolnet’ was used make the collaboration networks based on the coauthorship data in the original dataset [@SNASS]. Other functions are less complex, their purpose is described in short in notes, which can be found in the code below.

The smaller functions
```{r,eval=F}
#fpackage.check: Check if packages are installed (and install if not) in R
fpackage.check <- function(packages) {
    lapply(packages, FUN = function(x) {
        if (!require(x, character.only = TRUE)) {
            install.packages(x, dependencies = TRUE)
            library(x, character.only = TRUE)
        }
    })
}

#fsave: Save to processed data in repository
fsave <- function(x, file = NULL, location = "./data/processed/") {
    ifelse(!dir.exists("data"), dir.create("data"), FALSE)
    ifelse(!dir.exists("data/processed"), dir.create("data/processed"), FALSE)
    if (is.null(file))
        file = deparse(substitute(x))
    datename <- substr(gsub("[:-]", "", Sys.time()), 1, 8)
    totalname <- paste(location, datename, file, ".rda", sep = "")
    save(x, file = totalname)  #need to fix if file is reloaded as input name, not as x. 
}

#fload: To load the files back after an fsave
fload <- function(filename) {
    load(filename)
    get(ls()[ls() != "filename"])
}

#fshowdf: To print objects (tibbles / data.frame) nicely on screen in .rmd
fshowdf <- function(x, ...) {
    knitr::kable(x, digits = 2, "html", ...) %>%
        kableExtra::kable_styling(bootstrap_options = c("striped", "hover")) %>%
        kableExtra::scroll_box(width = "100%", height = "300px")
}

#String uniforming function
funiform_string <- function(input, numbers=TRUE, spaces=TRUE, caps=TRUE){
  string <- iconv(input, from = "UTF-8", to = "ASCII//TRANSLIT")
  string <- gsub('-','',string)
  if (numbers) string <- gsub('[0-9]','',string)
  if (spaces) string <- gsub(' ','',string)
  if (caps) string <- tolower(string)
  return(string)
}

#Network statistics functions, courtesy of Niels Vullings
#---- Jaccard Index ----
fjac <- function(net1, net2) {
  
  diag(net1) <- NA
  diag(net2) <- NA
  tj <- table(as.numeric(net1), as.numeric(net2)) 
  jaccard <- tj[2,2] /(tj[1,2] + tj[2,1] + tj[2,2])
  hamming <- tj[2,1] + tj[1,2]
  
  return(jaccard)
  
}

#---- Density ----
fdens <- function(N, data = net, directed = TRUE) {
  
  if (directed == TRUE) {
    pos_tie <- (N * (N - 1))
  } else {
    pos_tie <- (N * (N - 1))/2
    
  }
  
  obs_tie <- sum(sna::dyad.census(data)[1:2])
  dens <- obs_tie/pos_tie
  
  return(dens)
}

#Checking for required packages
packages = c("RSiena", "devtools", "igraph", "tidyverse", "xml2", "rvest", "dplyr", "stringr", "sna")
fpackage.check(packages)
```

The network data creation function
```{r,eval=F}
#Network data helper function
fcolnet = function(data = scholars, university = c("RU", 'UU'), discipline = "Sociologie", waves = list(c(2015,
    2018), c(2019, 2023), c(2024, 2025)), type = c("first")) {

    university = paste0('(', paste0(university, collapse='|' ), ')')
    discipline = paste0('(', paste0(discipline, collapse='|' ), ')')

    # step 1
    demographics = data$demographics
    sample = which(
        (str_detect(demographics$universiteit.22, university)
            | str_detect(demographics$universiteit.24, university)
            | str_detect(demographics$universiteit.25, university)
        ) & (
            str_detect(demographics$discipline.22, discipline)
            | str_detect(demographics$discipline.24, discipline)
            | str_detect(demographics$discipline.25, discipline)
        ) |> replace_na(FALSE))

    demographics_soc = demographics[sample, ] |> drop_na(id)

    # step 2
    ids = demographics_soc$id |> unique()


    scholars_sel = list() 
    for (id_ in ids){
        scholars_sel[[id_]] = bind_rows(scholars$works) |>
            filter(author_id == id_)
    }
    scholars_sel = bind_rows(scholars$works) 
    

    nwaves = length(waves)
    nets = array(0, dim = c(nwaves, length(ids), length(ids)), dimnames = list(wave = 1:nwaves, ids,
        ids))
    dimnames(nets)

    # step 3
    df_works = tibble(
            works_id = scholars_sel$id, 
            works_author = scholars_sel$authorships, 
            works_year = scholars_sel$publication_year
        )


    df_works = df_works[!duplicated(df_works), ]

    # step 4
    if (type == "first") {
        for (j in 1:length(waves)) {
            df_works_w = df_works[df_works$works_year >= waves[[j]][1] & df_works$works_year <= waves[[j]][2],
                ]
            for (i in 1:nrow(df_works_w)) {
                ego = df_works_w$works_author[i][[1]]$id[1]
                alters = df_works_w$works_author[i][[1]]$id[-1]
                if (sum(ids %in% ego) > 0 & sum(ids %in% alters) > 0) {
                  nets[j, which(ids %in% ego), which(ids %in% alters)] = 1
                }
            }
        }
    }

    if (type == "last") {
        for (j in 1:length(waves)) {
            df_works_w = df_works[df_works$works_year >= waves[[j]][1] & df_works$works_year <= waves[[j]][2],
                ]
            for (i in 1:nrow(df_works_w)) {
                ego = rev(df_works_w$works_author[i][[1]]$id[1])
                alters = rev(df_works_w$works_author[i][[1]]$id[-1])
                if (sum(ids %in% ego) > 0 & sum(ids %in% alters) > 0) {
                  nets[j, which(ids %in% ego), which(ids %in% alters)] = 1
                }
            }
        }
    }
    if (type == "all") {
        for (j in 1:length(waves)) {
            df_works_w = df_works[df_works$works_year >= waves[[j]][1] & df_works$works_year <= waves[[j]][2],
                ]
            for (i in 1:nrow(df_works_w)) {
                egos = df_works_w$works_author[i][[1]]$id
                if (sum(ids %in% egos) > 0) {
                  nets[j, which(ids %in% egos), which(ids %in% egos)] = 1
                }
            }
            diag(nets[j,,]) = 0
        }
    }

    output = list()
    output$data = demographics_soc
    output$nets = nets
    return(output)
}
```

The first step in the data preparation is making the collaboration network and waves
```{r,eval=F}

#Loading the data
scholars<-fload('C://Users/groot/Documents/RDirectory/20251016scholars.rda')

#Selecting for sociologists and transforming using the network data helper function
sndata1 = fcolnet(scholars, university = c('RU', 'UU', 'UvA', 'RUG', 'VU', 'UvT', 'EUR'),
                  waves = list(c(2015,2020)
                             , c(2021,2025)))
df_ego1 = bind_rows(sndata1$data)

#Making waves
wave1 = sndata1$nets[1,,]
wave2 = sndata1$nets[2,,]

#Making the waves back into a single file
nets = array(
    data = c(wave1, wave2),
    dim = c(dim(wave2), 2))

#Making the RSiena nomination matrix
net = sienaDependent(nets)
```

## ICS affiliation variables

Affiliation with the graduate school ICS was not included by default in the dataset, the ICS affiliation variables were constructed by webscraping publicly available lists of graduates and affiliated staff members from the ICS website [@ICS]. This yielded lists of names which could then be matched to the names of sociologists in the main dataset, allowing the ICS affiliation variables to be merged in. There are three separate ICS affiliation variables, all three are dummy variables. The variable ‘icsGraduate’ has the value ‘1’ if a persons name appeared in the list of ICS graduates, otherwise it has the value ‘0’. The variable ‘icsAffiliate’ has the value ‘1’ if a persons name appeared in the tables of affiliated staff members on the ICS website, otherwise it has the value ‘0’. The final variable, ‘icsAny’, serves as a summary of the other two. ‘icsAny’ has the value ‘1’ if ‘icsGraduate’ or ‘icsAffiliate’ is ‘1’, otherwise it is ‘0’. Details of the variable construction can be found in the code below.	 The reason that both having graduated and being affiliated are both treated as being part of ICS is that using only the list of ICS graduates could have lead to an underestimation of the effect of graduate school affiliation, because sociologists who join ICS after their PhD may still have a preference to work with likeminded others, who can be found at ICS. The two separate ICS variables are later used to estimate an additional RSiena model as a robustness check. All three ICS variables were implemented as 'sameX' effects in RSiena, this means that the expected effect of the variables was that formation and maintenance of ties should be more likely if an alter has the exact same value on an ICS variable as ego. Given that the variables are dummies, this would mean that tie formation should be more likely between two nodes whose values are both '1' or both '0'.

ICS variables frequencies
```{r}
#Generate frequency table for ICS variables

#Defining function again because it doesnt work otherwise
require(tidyr)
#fshowdf: To print objects (tibbles / data.frame) nicely on screen in .rmd
fshowdf <- function(x, ...) {
    knitr::kable(x, digits = 2, "html", ...) %>%
        kableExtra::kable_styling(bootstrap_options = c("striped", "hover")) %>%
        kableExtra::scroll_box(width = "100%", height = "300px")
}

#Frequency table ICS
ValueICS<-c('Non affiliate staff','Affiliate staff',
            'Non graduate','Graduate',
            'Total non affiliate','Total affiliate')
CountICS<-c(342,116,364,94,297,161)
freICSdf<-data.frame(Value=ValueICS,Count=CountICS)

fshowdf(freICSdf)

```

ICS variables construction
```{r,eval=F}
#First we get the affiliates tables from https://ics-graduateschool.nl/

#Faculty 
icsfac<-read_html("https://ics-graduateschool.nl/faculty/") 
icsfac<-icsfac %>% html_nodes("body") %>% xml_find_all("//tbody") %>% html_table() 
icsfac<-bind_rows(icsfac) 
icsfac$X5<-"Faculty"

#Postdocs 
icspost<-read_html("https://ics-graduateschool.nl/postdocs/") 
icspost<-icspost %>% html_nodes("body") %>% xml_find_all("//tbody") %>% html_table() 
icspost<-bind_rows(icspost) 
icspost$X5<-"Postdoc"

#PhDs 
icsphd<-read_html("https://ics-graduateschool.nl/phds/") 
icsphd<-icsphd %>% html_nodes("body") %>% xml_find_all("//tbody") %>% html_table() 
icsphd<-bind_rows(icsphd) 
icsphd$X5<-"PhD"

#Merging into one table 
icsA<-rbind(icsfac,icspost) 
icsA<-rbind(icsA,icsphd)
icsA$icsAffiliate<-1

#Making first and last names into ID variable for matching
icsA$Naam<-paste(icsA$X1,icsA$X2)
icsA$Naam<-funiform_string(icsA$Naam)

#Then we get the list of graduates from the same website
icsG<-read_html("https://ics-graduateschool.nl/alumni-projects/")
icsG<-icsG %>%
  html_nodes("body") %>%
  xml_find_all("//tbody") %>%
  html_table()
icsG<-bind_rows(icsG)
icsG$icsGraduate<-1
icsG$Naam<-funiform_string(icsG$X2)

#Merging the ICS affiliates and graduates tables
icsC<-merge(icsA, icsG, all = TRUE, by = "Naam")
icsC$unaam<-icsC$Naam
icsF<-icsC[c('unaam','icsAffiliate','icsGraduate')]
icsF$icsAny<-1
icsF[is.na(icsF)]<-0

#Adding uniformed author names to the ego level data
df_ego1$unaam<-funiform_string(df_ego1$naam)

#Merging the ICS variables into the ego level data
df_ego2<-merge(x=df_ego1,y=icsF,all.x=TRUE)

#Replacing missings on the ICS variables with 0 to complete the dummies
df_ego2$icsAffiliate[is.na(df_ego2$icsAffiliate)]<-0
df_ego2$icsGraduate[is.na(df_ego2$icsGraduate)]<-0
df_ego2$icsAny[is.na(df_ego2$icsAny)]<-0

```

## University affiliation variable

The university where a sociologist works was included as a variable in the original dataset for each of the three years for which data is available. Since university was needed as a control variable and not a dependent variable, it was decided to make the three university variables into a single time constant variable. This was done by taking the university affiliation in 2022, if there was no affiliation for 2022, the affiliation for 2024 was taken and if that was missing as well the 2025 university affiliation was used. This way, the ‘universityS’ variable registers a single university for each sociologist. The ‘universityN’ variable was then constructed as a nominal numeric variable for inclusion in RSiena. Though university affiliation was not coded as dummy variables, but a numeric nominal variable, it was also implemented in RSiena as a sameX effect. So tie formation and maintenance should be more likely between nodes who have the exact same value for the university variable, which represents them working at the same university.

University frequencies
```{r}
#Frequency table university
Valueuni<-c('UvA','VU','EUR','UU','RU','TiU','RUG')
Countuni<-c(76,87,50,57,52,32,104)
freUNIdf<-data.frame(University=Valueuni,Count=Countuni)
fshowdf(freUNIdf)

```

Transformation of the university variables
```{r,eval=F}
#First of, the 'universiteit' variables for each year
#These variables indicate for each sociologist in the data at which university they worked in each year

#Inspecting the variables with frequency tables
table(df_ego2$universiteit.22,useNA='always')
table(df_ego2$universiteit.24,useNA='always')
table(df_ego2$universiteit.25,useNA='always')

#The frequency tables show that there are several sociologist who work at two universities
#Some of these work at a Dutch university and a foreign one, 
#those cases are now recoded to include only the Dutch university
df_ego3<-df_ego2
df_ego3$universiteit.22<-gsub('EUR/Boston University', 'EUR', df_ego3$universiteit.22)
df_ego3$universiteit.24<-gsub('EUR/Boston University', 'EUR', df_ego3$universiteit.24)
df_ego3$universiteit.22<-gsub('RUG/TU Delft', 'RUG', df_ego3$universiteit.22)
df_ego3$universiteit.24<-gsub('RUG/TU Delft', 'RUG', df_ego3$universiteit.24)
df_ego3$universiteit.22<-gsub('RUG/Universiteit Stockholm', 'RUG', df_ego3$universiteit.22)
df_ego3$universiteit.24<-gsub('RUG/Universiteit Stockholm', 'RUG', df_ego3$universiteit.24)
df_ego3$universiteit.22<-gsub('RUG/University Linköping', 'RUG', df_ego3$universiteit.22)
df_ego3$universiteit.24<-gsub('RUG/University Linköping', 'RUG', df_ego3$universiteit.24)
df_ego3$universiteit.22<-gsub('RUG/University of Turku', 'RUG', df_ego3$universiteit.22)
df_ego3$universiteit.24<-gsub('RUG/University of Turku', 'RUG', df_ego3$universiteit.24)
df_ego3$universiteit.22<-gsub('UvA/Frankfurt School of Finance & Management', 'UvA', df_ego3$universiteit.22)
df_ego3$universiteit.24<-gsub('UvA/Frankfurt School of Finance & Management', 'UvA', df_ego3$universiteit.24)
df_ego3$universiteit.22<-gsub('UvA/University of Lausanne', 'UvA', df_ego3$universiteit.22)
df_ego3$universiteit.24<-gsub('UvA/University of Lausanne', 'UvA', df_ego3$universiteit.24)
df_ego3$universiteit.22<-gsub('UvT/Trento University', 'UvT', df_ego3$universiteit.22)
df_ego3$universiteit.24<-gsub('UvT/Trento University', 'UvT', df_ego3$universiteit.24)
df_ego3$universiteit.22<-gsub('VU/UvH', 'VU', df_ego3$universiteit.22)
df_ego3$universiteit.24<-gsub('VU/UvH', 'VU', df_ego3$universiteit.24)
df_ego3$universiteit.24<-gsub('RUG/University of Leipzig', 'RUG', df_ego3$universiteit.24)

#And make only foreign university into NA and remove question marks
df_ego3$universiteit.24<-gsub('University of Cologne', NA, df_ego3$universiteit.24)
df_ego3$universiteit.24<-gsub('[?]', '', df_ego3$universiteit.24)

#Checking the frequencies again
table(df_ego3$universiteit.22,useNA='always')
table(df_ego3$universiteit.24,useNA='always')
table(df_ego3$universiteit.25,useNA='always')

#Now most of the cases are fine, except for the few that have two universities
#For these cases the first of the two reported universities is taken as primary,
#and is thus selected as the value of the university variable
#Loss of information was accepted in this case because adding a 'second university' variable for 5 sociologists
#would mean changing the analysis quite substantially for what is likely to be no significant difference
df_ego3$universiteit.22<-gsub('RU/RUG', 'RU', df_ego3$universiteit.22)
df_ego3$universiteit.24<-gsub('RU/RUG', 'RU', df_ego3$universiteit.24)
df_ego3$universiteit.22<-gsub('RUG/RU', 'RUG', df_ego3$universiteit.22)
df_ego3$universiteit.24<-gsub('RUG/RU', 'RUG', df_ego3$universiteit.24)
df_ego3$universiteit.22<-gsub('RUG/Tilburg', 'RUG', df_ego3$universiteit.22)
df_ego3$universiteit.24<-gsub('RUG/Tilburg', 'RUG', df_ego3$universiteit.24)
df_ego3$universiteit.22<-gsub('UvA/EUR', 'UvA', df_ego3$universiteit.22)
df_ego3$universiteit.22<-gsub('UU/UvA', 'UU', df_ego3$universiteit.22)
df_ego3$universiteit.24<-gsub('UU/UvA', 'UU', df_ego3$universiteit.24)

#Checking frequencies again
table(df_ego3$universiteit.22,useNA='always')
table(df_ego3$universiteit.24,useNA='always')
table(df_ego3$universiteit.25,useNA='always')

#There are no more strange values for the 'universiteit' variables

#I want there to be one variable indicating the university each sociologist is most affiliated with
#By most affiliated I mainly mean how long they were affiliated with a university, so where they would have
#spent the most time and presumably, as is most relevant, collaborated most
#As such, the basis for the 'university' variable will be the 'universiteit.22' variable, with any missing
#values on this variable being supplemented first with 'universiteit.24' and then 'universiteit.25' if needed

#In order to do this, the universities with three letter abbreviations are abbreviated to two letters
#2022
df_ego3$uni22<-df_ego3$universiteit.22
df_ego3$uni22<-gsub('EUR','EU',df_ego3$uni22)
df_ego3$uni22<-gsub('RUG','UG',df_ego3$uni22)
df_ego3$uni22<-gsub('UvA','UA',df_ego3$uni22)
df_ego3$uni22<-gsub('UvT','UT',df_ego3$uni22)

#2024
df_ego3$uni24<-df_ego3$universiteit.24
df_ego3$uni24<-gsub('EUR','EU',df_ego3$uni24)
df_ego3$uni24<-gsub('RUG','UG',df_ego3$uni24)
df_ego3$uni24<-gsub('UvA','UA',df_ego3$uni24)
df_ego3$uni24<-gsub('UvT','UT',df_ego3$uni24)

#2025
df_ego3$uni25<-df_ego3$universiteit.25
df_ego3$uni25<-gsub('EUR','EU',df_ego3$uni25)
df_ego3$uni25<-gsub('RUG','UG',df_ego3$uni25)
df_ego3$uni25<-gsub('UvA','UA',df_ego3$uni25)
df_ego3$uni25<-gsub('UvT','UT',df_ego3$uni25)

#Check if this worked
table(df_ego3$uni22,df_ego3$universiteit.22,useNA='always')
table(df_ego3$uni24,df_ego3$universiteit.24,useNA='always')
table(df_ego3$uni25,df_ego3$universiteit.25,useNA='always')

#This worked, all universities now use two letter abbreviations
#Now to make one variable which includes only the earliest university available for each sociologist
df_ego3$university<-paste(df_ego3$uni22,df_ego3$uni24,df_ego3$uni25)
df_ego3$university<-gsub('NA','',df_ego3$university)
df_ego3$university<-gsub(' ','',df_ego3$university)
df_ego3$university<-substr(df_ego3$university,start=1,stop=2)

#Check if this worked by inspecting a list
universityCheck<-cbind.data.frame(df_ego3$uni22,df_ego3$uni24,df_ego3$uni25,df_ego3$university)
view(universityCheck)
rm(universityCheck)

#Distribution of the new 'university' variable
table(df_ego3$university,useNA='always')

#Now as a final transformation, the variable will be made numeric for use in RSiena
df_ego3$universityN<-df_ego3$university
df_ego3$universityN<-gsub('EU',0,df_ego3$universityN)
df_ego3$universityN<-gsub('RU',1,df_ego3$universityN)
df_ego3$universityN<-gsub('UA',2,df_ego3$universityN)
df_ego3$universityN<-gsub('UG',3,df_ego3$universityN)
df_ego3$universityN<-gsub('UT',4,df_ego3$universityN)
df_ego3$universityN<-gsub('UU',5,df_ego3$universityN)
df_ego3$universityN<-gsub('VU',6,df_ego3$universityN)

#Final check
table(df_ego3$university,df_ego3$universityN)

```

## Job function variable

The function of each sociologist was also included in the original data. Working by the same logic, this variable was also transformed into the time constant variables ‘functionS’ and ‘functionN’, which are the string and numeric versions respectively. Nine sociologists had ‘staff’ as their value for the function variable, this value was deemed uninformative and as such was substituted with a function from another year where possible. When no function value other than ‘staff’ was available, the sociologist in question was given a more informative value based on their university web page or Linkedin job history. Looking people up on Linkedin was deemed ethical on the grounds that Linkedin is a networking and job searching website, so the information available there is intended by the user to be accessible to others they do not personally know. The function variable was implemented in RSiena as an 'unequalX' effect, this means that nodes are expected to have a preference for tie formation with other nodes who have any value of function different from their own. This is meant to capture the collaborations between senior and junior staff as stemming from supervision on the part of seniors, instead of a sameX effect of ICS affiliation.

Frequencies of function
```{r}
#Frequency table function
Valuefun<-c('PhD student','Postdoc','Lecturer','Researcher',
            'Assistant professor','Associate professor','Full professor')
Countfun<-c(146,21,27,39,92,43,77)
freFUNdf<-data.frame(Function=Valuefun,Count=Countfun)
fshowdf(freFUNdf)

```

Transformation of the function variable
```{r,eval=F}
#Now on to the 'functie' variables, these show the sociologists' job titles
table(df_ego3$functie.22,useNA='always')
table(df_ego3$functie.24,useNA='always')
table(df_ego3$functie.25,useNA='always')

#There is one slightly nondescript value here, namely 'staff'
#For the few people with this value, 
#I decided to first see if a more informative title is given in another year, 
#then check university websites and social media
#Nine sociologist were given more informative values for the function variable this way
df_ego3$funcsub<-df_ego3$functie.22
df_ego3[86,'funcsub']<-'PhD Candidate'
df_ego3[89,'funcsub']<-'Researcher'
df_ego3[143,'funcsub']<-'Assistant Professor'
df_ego3[190,'funcsub']<-'Lecturer'
df_ego3[284,'funcsub']<-'Lecturer'
df_ego3[385,'funcsub']<-'Researcher'
df_ego3[418,'funcsub']<-'Full Professor'
df_ego3[419,'funcsub']<-'Researcher'
df_ego3[431,'funcsub']<-'Lecturer'

#Check distribution
table(df_ego3$funcsub,useNA='always')

#The next variable to transform is 'function'
#The same logic is applied here, the goal is one variable which indicates which function each sociologist had
#The 2022 function is preferred to 2024 and 2025 functions, again with the argument that any changes in function
#which occured this year (2025) or last year (2024) compared to 2022 would have had less of an effect on the 
#publication record and collaborations of each sociologist than the function they had in 2022.

#Because of the more heterogenous string length of the function variables as compared to the university 
#variables, they are first made into numbers, then combined, then the first is selected, which is then
#transformed back into the original string

#Making the function variables into numbers
#2022 (funcsub is used because it has the imputed missings)
df_ego3$func22<-df_ego3$funcsub
df_ego3$func22<-gsub('PhD Candidate','0',df_ego3$func22)
df_ego3$func22<-gsub('Postdoctoral Researcher','1',df_ego3$func22)
df_ego3$func22<-gsub('Lecturer','2',df_ego3$func22)
df_ego3$func22<-gsub('Researcher','3',df_ego3$func22)
df_ego3$func22<-gsub('Assistant Professor','4',df_ego3$func22)
df_ego3$func22<-gsub('Associate Professor','5',df_ego3$func22)
df_ego3$func22<-gsub('Full Professor','6',df_ego3$func22)

#2024
df_ego3$func24<-df_ego3$functie.24
df_ego3$func24<-gsub('PhD Candidate','0',df_ego3$func24)
df_ego3$func24<-gsub('Postdoctoral Researcher','1',df_ego3$func24)
df_ego3$func24<-gsub('Lecturer','2',df_ego3$func24)
df_ego3$func24<-gsub('Researcher','3',df_ego3$func24)
df_ego3$func24<-gsub('Assistant Professor','4',df_ego3$func24)
df_ego3$func24<-gsub('Associate Professor','5',df_ego3$func24)
df_ego3$func24<-gsub('Full Professor','6',df_ego3$func24)

#2025
df_ego3$func25<-df_ego3$functie.25
df_ego3$func25<-gsub('PhD Candidate','0',df_ego3$func25)
df_ego3$func25<-gsub('Postdoctoral Researcher','1',df_ego3$func25)
df_ego3$func25<-gsub('Lecturer','2',df_ego3$func25)
df_ego3$func25<-gsub('Researcher','3',df_ego3$func25)
df_ego3$func25<-gsub('Assistant Professor','4',df_ego3$func25)
df_ego3$func25<-gsub('Associate Professor','5',df_ego3$func25)
df_ego3$func25<-gsub('Full Professor','6',df_ego3$func25)

#Check values if the values correspond
functionCheck<-cbind.data.frame(
  df_ego3$funcsub,df_ego3$func22,df_ego3$functie.24,df_ego3$func24,df_ego3$functie.25,df_ego3$func25)
view(functionCheck)
rm(functionCheck)

#The values are as intended, now to merge the numbers, extract the first and make it back into a word
df_ego3$functionN<-paste(df_ego3$func22,df_ego3$func24,df_ego3$func25)
df_ego3$functionN<-gsub('NA','',df_ego3$functionN)
df_ego3$functionN<-gsub(' ','',df_ego3$functionN)
df_ego3$functionN<-substr(df_ego3$functionN,start=1,stop=1)
table(df_ego3$functionN,useNA='always')

#Now to make the variable actually numeric
df_ego3$functionN<-gsub('0',0,df_ego3$functionN)
df_ego3$functionN<-gsub('1',1,df_ego3$functionN)
df_ego3$functionN<-gsub('2',2,df_ego3$functionN)
df_ego3$functionN<-gsub('3',3,df_ego3$functionN)
df_ego3$functionN<-gsub('4',4,df_ego3$functionN)
df_ego3$functionN<-gsub('5',5,df_ego3$functionN)
df_ego3$functionN<-gsub('6',6,df_ego3$functionN)
table(df_ego3$functionN,useNA='always')

#And create a string version for easy reference
df_ego3$functionS<-df_ego3$functionN
df_ego3$functionS<-gsub('0','PhD Candidate',df_ego3$functionS)
df_ego3$functionS<-gsub('1','Postdoctoral Researcher',df_ego3$functionS)
df_ego3$functionS<-gsub('2','Lecturer',df_ego3$functionS)
df_ego3$functionS<-gsub('3','Researcher',df_ego3$functionS)
df_ego3$functionS<-gsub('4','Assistant Professor',df_ego3$functionS)
df_ego3$functionS<-gsub('5','Associate Professor',df_ego3$functionS)
df_ego3$functionS<-gsub('6','Full Professor',df_ego3$functionS)
table(df_ego3$functionS,useNA='always')

#Check if the values are correct
functionCheck<-cbind.data.frame(
  df_ego3$funcsub,df_ego3$func22,df_ego3$functie.24,df_ego3$func24,df_ego3$functie.25,df_ego3$func25,
  df_ego3$functionN,df_ego3$functionS)
view(functionCheck)
rm(functionCheck)

#Turns out there are still 13 missings, these are marked NA
df_ego3[46,'functionN']<-NA
df_ego3[46,'functionS']<-NA
df_ego3[125,'functionN']<-NA
df_ego3[125,'functionS']<-NA
df_ego3[174,'functionN']<-NA
df_ego3[174,'functionS']<-NA
df_ego3[188,'functionN']<-NA
df_ego3[188,'functionS']<-NA
df_ego3[195,'functionN']<-NA
df_ego3[195,'functionS']<-NA
df_ego3[237,'functionN']<-NA
df_ego3[237,'functionS']<-NA
df_ego3[248,'functionN']<-NA
df_ego3[248,'functionS']<-NA
df_ego3[274,'functionN']<-NA
df_ego3[274,'functionS']<-NA
df_ego3[324,'functionN']<-NA
df_ego3[324,'functionS']<-NA
df_ego3[355,'functionN']<-NA
df_ego3[355,'functionS']<-NA
df_ego3[375,'functionN']<-NA
df_ego3[375,'functionS']<-NA
df_ego3[403,'functionN']<-NA
df_ego3[403,'functionS']<-NA
df_ego3[457,'functionN']<-NA
df_ego3[457,'functionS']<-NA

#Check again
table(df_ego3$functionN,df_ego3$functionS,useNA='always')

#Now the string and numeric function variables are as intended

```

## Gender variable

The gender variable that was included in the dataset was constructed using an algorithm which determines a persons gender based on their first name, since most names are more common for either men or women, this leads to an estimate of the sociologists genders with reasonable accuracy. There were five sociologists with a missing value for the gender variable, this was caused by the inclusion of only their initials in the dataset instead of complete first names. The missings were handled by imputing values based on the sociologists university webpages. The gender variable was then transformed into ‘genderN’, which is a numeric dummy with ‘0’ indicating women and ‘1’ indicating men. Gender was implemented in RSiena as a sameX effect, reflecting a tendency towards tie formation with alters who have the same gender as ego.

Frequencies gender
```{r}
#Frequency table gender
Valuegen<-c('Female','Male')
Countgen<-c(245,213)
freGENdf<-data.frame(Gender=Valuegen,Count=Countgen)
fshowdf(freGENdf)  

```

Transformation of the gender variable
```{r,eval=F}
#Lastly there is the gender variable, which has five missings
table(df_ego3$gender,useNA='always')

#These missings were imputed by googling their name and the university they work at
#A picture was found for all five, gender was inferred based on gender signifiers seen in the pictures
#Main signifiers used were length of hair and presence of prominent facial hair
df_ego3[123,'gender']<-'female'
df_ego3[237,'gender']<-'male'
df_ego3[375,'gender']<-'female'
df_ego3[412,'gender']<-'male'
df_ego3[462,'gender']<-'female'

#Checking to make sure there are no more missings for gender
table(df_ego3$gender,useNA='always')

#Lastly the gender variable was made into a dummy
df_ego3$genderN<-df_ego3$gender
df_ego3$genderN<-gsub('female',0,df_ego3$genderN)
df_ego3$genderN<-gsub('male',1,df_ego3$genderN)

#Check if the values correspond to the original variable
table(df_ego3$gender,df_ego3$genderN,useNA='always')

```

## Clustering coefficients

Two indicators were used for clustering, the variable of interest in hypothesis 2. First, the transitivity was used as an indicator for clustering, this is also called the global clustering coefficient [@Watts]. The transitivity is the number of transitive triads divided by the total possible number of transitive triads. In addition to network level transitivity (transG), clustering is measured using the average of local transitivity (transA). This was done because the network level transitivity places more weight on high degree nodes, whereas the average local transitivity places more weight on low degree nodes. By analysing both metrics, a more complete picture of the extent of clustering can be shown. The values of these variables were calculated during the analysis, and are reported there. It should be noted again that the transitivity scores are not meant to indicate whether the network can be accurately described as having a small-world structure, the assessment only needs to show if clustering increases if the sameX effect of the ICS variable is increased in simulations. 


## Final data preparation steps

The last steps in data preparation are the removal of duplicate cases and the transformation of the ego level variables into RSiena covariate objects. The default mean centering for RSiena covariates is turned off, this was done because the variables are all intended to be treated as nominal. 
```{r,eval=F}
#Ensure there are no duplicate cases in the dataset before converting to RSiena object
table(df_ego3$unaam)

#There are a few duplicates, they are removed
df_egoF<-df_ego3[!duplicated(df_ego3[c('unaam')]), ]

#With the data cleaned, it can now be made into an RSiena data object
#Some still need to be marked as numeric, which does not change the values in this case
df_egoF$universityN<-as.numeric(df_egoF$universityN)
universityN<-coCovar(df_egoF$universityN,centered=FALSE)
df_egoF$functionN<-as.numeric(df_egoF$functionN)
functionO<-coCovar(df_egoF$functionN,centered=FALSE)
df_egoF$genderN<-as.numeric(df_egoF$genderN)
genderD<-coCovar(df_egoF$genderN,centered=FALSE)
icsanyD<-coCovar(df_egoF$icsAny,centered=FALSE)
icsaffilD<-coCovar(df_egoF$icsAffiliate,centered=FALSE)
icsgradD<-coCovar(df_egoF$icsGraduate,centered=FALSE)

#Making the data object
collabnet1<-sienaDataCreate(net, universityN, functionO, genderD, icsanyD, icsaffilD, icsgradD)

```

